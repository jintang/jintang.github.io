<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>堂的博客</title>
  <subtitle>给岁月以学习,而不是给学习以岁月</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jintang.github.io/"/>
  <updated>2019-12-20T07:23:52.675Z</updated>
  <id>https://jintang.github.io/</id>
  
  <author>
    <name>堂</name>
    <email>LCX6916356@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>EM算法</title>
    <link href="https://jintang.github.io/2019/12/19/EM%E7%AE%97%E6%B3%95/"/>
    <id>https://jintang.github.io/2019/12/19/EM算法/</id>
    <published>2019-12-19T14:52:03.000Z</published>
    <updated>2019-12-20T07:23:52.675Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>引用自 <a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/Machine%20Learning/6.%20EM" target="_blank" rel="noopener">NLP-LOVE/ML-NLP</a></p></blockquote><h2 id="什么是EM算法"><a href="#什么是EM算法" class="headerlink" title="什么是EM算法"></a>什么是EM算法</h2><p>数据挖掘十大算法之一的EM算法。</p><p>最大期望算法（Expectation-maximization algorithm，又译为期望最大化算法），是在概率模型中寻找参数最大似然估计或者最大后验估计的算法，其中概率模型依赖于无法观测的隐性变量。</p><p>最大期望算法经过两个步骤交替进行计算，</p><p><strong>第一步</strong>是计算期望（E），利用对隐藏变量的现有估计值，计算其最大似然估计值；<br><strong>第二步</strong>是最大化（M），最大化在E步上求得的最大似然值来计算参数的值。M步上找到的参数估计值被用于下一个E步计算中，这个过程不断交替进行。</p><p>极大似然估计用一句话概括就是：知道结果，反推条件θ。</p><a id="more"></a><h3 id="似然函数"><a href="#似然函数" class="headerlink" title="似然函数"></a>似然函数</h3><p>在数理统计学中，<strong>似然函数</strong>是一种关于统计模型中的参数的函数，表示模型参数中的似然性。“似然性”与“或然性”或“概率”意思相近，都是指某种事件发生的可能性。<strong>而极大似然就相当于最大可能的意思。</strong></p><p>比如你一位同学和一位猎人一起外出打猎，一只野兔从前方窜过。只听一声枪响，野兔应声到下，如果要你推测，这一发命中的子弹是谁打的？你就会想，只发一枪便打中，由于猎人命中的概率一般大于你那位同学命中的概率，从而推断出这一枪应该是猎人射中的。</p><p>这个例子所作的推断就体现了最大似然法的基本思想。</p><p><strong>多数情况下我们是根据已知条件来推算结果，而最大似然估计是已经知道了结果，然后寻求使该结果出现的可能性最大的条件，以此作为估计值。</strong></p><h3 id="极大似然函数的求解步骤"><a href="#极大似然函数的求解步骤" class="headerlink" title="极大似然函数的求解步骤"></a>极大似然函数的求解步骤</h3><p>假定我们要从10万个人当中抽取100个人来做身高统计，那么抽到这100个人的概率就是(概率连乘)：</p><p><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/em_1.png" alt="em_1"></p><p>现在要求的就是这个 $\theta$ 值，也就是使得 $L(\theta)$ 的概率最大化，那么这时的参数 $\theta$ 就是所求。</p><p>为了便于分析，我们可以定义对数似然函数，将其变成连加的形式：</p><p><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/em_2.png" alt="em_2"></p><p>对于求一个函数的极值，通过我们在本科所学的微积分知识，最直接的设想是求导，然后让导数为0，那么解这个方程得到的θ就是了（当然，前提是函数L(θ)连续可微）。但，如果θ是包含多个参数的向量那怎么处理呢？当然是求L(θ)对所有参数的偏导数，也就是梯度了，从而n个未知的参数，就有n个方程，方程组的解就是似然函数的极值点了，最终得到这n个参数的值。</p><p>求极大似然函数估计值的一般步骤：</p><ol><li>写出似然函数；</li><li>对似然函数取对数，并整理；</li><li>求导数，令导数为0，得到似然方程；</li><li>解似然方程，得到的参数即为所求；</li></ol><h3 id="EM算法"><a href="#EM算法" class="headerlink" title="EM算法"></a>EM算法</h3><p>两枚硬币A和B，假定随机抛掷后正面朝上概率分别为PA，PB。为了估计这两个硬币朝上的概率，咱们轮流抛硬币A和B，每一轮都连续抛5次，总共5轮：</p><table><thead><tr><th>硬币</th><th>结果</th><th>统计</th></tr></thead><tbody><tr><td>A</td><td>正正反正反</td><td>3正-2反</td></tr><tr><td>B</td><td>反反正正反</td><td>2正-3反</td></tr><tr><td>A</td><td>正反反反反</td><td>1正-4反</td></tr><tr><td>B</td><td>正反反正正</td><td>3正-2反</td></tr><tr><td>A</td><td>反正正反反</td><td>2正-3反</td></tr></tbody></table><p>硬币A被抛了15次，在第一轮、第三轮、第五轮分别出现了3次正、1次正、2次正，所以很容易估计出PA，类似的，PB也很容易计算出来(<strong>真实值</strong>)，如下：</p><p>PA = （3+1+2）/ 15 = 0.4<br>PB= （2+3）/10 = 0.5</p><p>问题来了，如果我们不知道抛的硬币是A还是B呢（即硬币种类是隐变量），然后再轮流抛五轮，得到如下结果：</p><table><thead><tr><th>硬币</th><th>结果</th><th>统计</th></tr></thead><tbody><tr><td>Unknown</td><td>正正反正反</td><td>3正-2反</td></tr><tr><td>Unknown</td><td>反反正正反</td><td>2正-3反</td></tr><tr><td>Unknown</td><td>正反反反反</td><td>1正-4反</td></tr><tr><td>Unknown</td><td>正反反正正</td><td>3正-2反</td></tr><tr><td>Unknown</td><td>反正正反反</td><td>2正-3反</td></tr></tbody></table><p>OK，问题变得有意思了。现在我们的目标没变，还是估计PA和PB，需要怎么做呢？</p><p>显然，此时我们多了一个硬币种类的隐变量，设为z，可以把它认为是一个5维的向量（z1,z2,z3,z4,z5)，代表每次投掷时所使用的硬币，比如z1，就代表第一轮投掷时使用的硬币是A还是B。</p><ul><li>但是，这个变量z不知道，就无法去估计PA和PB，所以，我们必须先估计出z，然后才能进一步估计PA和PB。</li><li>可要估计z，我们又得知道PA和PB，这样我们才能用极大似然概率法则去估计z，这不是鸡生蛋和蛋生鸡的问题吗，如何破？</li></ul><p>答案就是先随机初始化一个PA和PB，用它来估计z，然后基于z，还是按照最大似然概率法则去估计新的PA和PB，然后依次循环，如果新估计出来的PA和PB和我们真实值差别很大，直到<strong>PA和PB收敛到真实值为止。</strong></p><p>我们不妨这样，先随便给PA和PB赋一个值，比如：<br>硬币A正面朝上的概率PA = 0.2<br>硬币B正面朝上的概率PB = 0.7</p><p>然后，我们看看第一轮抛掷最可能是哪个硬币。<br>如果是硬币A，得出3正2反的概率为 0.2*0.2*0.2*0.8*0.8 = 0.00512<br>如果是硬币B，得出3正2反的概率为 0.7*0.7*0.7*0.3*0.3=0.03087<br>然后依次求出其他4轮中的相应概率。做成表格如下：</p><table><thead><tr><th>轮数</th><th>若是硬币A</th><th>若是硬币B</th></tr></thead><tbody><tr><td>1</td><td>0.00512，即0.2 0.2 0.2 0.8 0.8，3正-2反</td><td><strong>0.03087</strong>，3正-2反</td></tr><tr><td>2</td><td><strong>0.02048</strong>，即0.2 0.2 0.8 0.8 0.8，2正-3反</td><td>0.01323，2正-3反</td></tr><tr><td>3</td><td><strong>0.08192</strong>，即0.2 0.8 0.8 0.8 0.8，1正-4反</td><td>0.00567，1正-4反</td></tr><tr><td>4</td><td>0.00512，即0.2 0.2 0.2 0.8 0.8，3正-2反</td><td><strong>0.03087</strong>，3正-2反</td></tr><tr><td>5</td><td><strong>0.02048</strong>，即0.2 0.2 0.8 0.8 0.8，2正-3反</td><td>0.01323，2正-3反</td></tr></tbody></table><p>按照最大似然法则：<br>第1轮中最有可能的是<strong>硬币B</strong><br>第2轮中最有可能的是<strong>硬币A</strong><br>第3轮中最有可能的是<strong>硬币A</strong><br>第4轮中最有可能的是<strong>硬币B</strong><br>第5轮中最有可能的是<strong>硬币A</strong></p><p>我们就把概率更大，即更可能是A的，即第2轮、第3轮、第5轮出现正的次数2、1、2相加，除以A被抛的总次数15（A抛了三轮，每轮5次），作为z的估计值，B的计算方法类似。然后我们便可以按照最大似然概率法则来估计新的PA和PB。</p><p>PA = （2+1+2）/15 = 0.33<br>PB =（3+3）/10 = 0.6</p><p>设想我们是全知的神，知道每轮抛掷时的硬币就是如本文本节开头标示的那样，那么，PA和PB的最大似然估计就是0.4和0.5（下文中将这两个值称为PA和PB的真实值）。那么对比下我们初始化的PA和PB和新估计出的PA和PB：</p><table><thead><tr><th>初始化的PA</th><th>估计出的PA</th><th>真实的PA</th><th>初始化的PB</th><th>估计出的PB</th><th>真实的PB</th></tr></thead><tbody><tr><td>0.2</td><td>0.33</td><td>0.4</td><td>0.7</td><td>0.6</td><td>0.5</td></tr></tbody></table><p>就这样，不断迭代 不断接近真实值，这就是EM算法的奇妙之处。</p><p>可以期待，我们继续按照上面的思路，用估计出的PA和PB再来估计z，再用z来估计新的PA和PB，反复迭代下去，就可以最终得到PA = 0.4，PB=0.5，此时无论怎样迭代，PA和PB的值都会保持0.4和0.5不变，于是乎，我们就找到了PA和PB的最大似然估计。</p><p><strong>总结一下计算步骤：</strong></p><ol><li><p>随机初始化分布参数θ</p></li><li><p>E步，求Q函数，对于每一个i，计算根据上一次迭代的模型参数来计算出隐性变量的后验概率（其实就是隐性变量的期望），来作为隐藏变量的现估计值：</p><p><img src="http://wx1.sinaimg.cn/mw690/00630Defly1g57brmij1wj307l01cq2s.jpg" alt></p></li><li><p>M步，求使Q函数获得极大时的参数取值）将似然函数最大化以获得新的参数值</p><p><img src="http://wx1.sinaimg.cn/mw690/00630Defly1g57bswusk1j30de01s3yh.jpg" alt></p></li><li><p>然后循环重复2、3步直到收敛。</p></li></ol><p>详细的推导过程请参考文末的参考文献。</p><h2 id="采用-EM-算法求解的模型有哪些？"><a href="#采用-EM-算法求解的模型有哪些？" class="headerlink" title="采用 EM 算法求解的模型有哪些？"></a>采用 EM 算法求解的模型有哪些？</h2><p>用EM算法求解的模型一般有GMM或者协同过滤，k-means其实也属于EM。EM算法一定会收敛，但是可能收敛到局部最优。由于求和的项数将随着隐变量的数目指数上升，会给梯度计算带来麻烦。</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>关于EM算法的应用其实很多，最广泛的就是GMM混合高斯模型、聚类、HMM等等。比如：<br><a href="https://github.com/NLP-LOVE/ML-NLP/tree/master/Machine%20Learning/6.%20EM/gmm_em" target="_blank" rel="noopener">高斯混合模型 EM 算法</a></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://blog.csdn.net/v_july_v/article/details/81708386" target="_blank" rel="noopener">如何通俗理解EM算法</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;引用自 &lt;a href=&quot;https://github.com/NLP-LOVE/ML-NLP/tree/master/Machine%20Learning/6.%20EM&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NLP-LOVE/ML-NLP&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;什么是EM算法&quot;&gt;&lt;a href=&quot;#什么是EM算法&quot; class=&quot;headerlink&quot; title=&quot;什么是EM算法&quot;&gt;&lt;/a&gt;什么是EM算法&lt;/h2&gt;&lt;p&gt;数据挖掘十大算法之一的EM算法。&lt;/p&gt;&lt;p&gt;最大期望算法（Expectation-maximization algorithm，又译为期望最大化算法），是在概率模型中寻找参数最大似然估计或者最大后验估计的算法，其中概率模型依赖于无法观测的隐性变量。&lt;/p&gt;&lt;p&gt;最大期望算法经过两个步骤交替进行计算，&lt;/p&gt;&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;是计算期望（E），利用对隐藏变量的现有估计值，计算其最大似然估计值；&lt;br&gt;&lt;strong&gt;第二步&lt;/strong&gt;是最大化（M），最大化在E步上求得的最大似然值来计算参数的值。M步上找到的参数估计值被用于下一个E步计算中，这个过程不断交替进行。&lt;/p&gt;&lt;p&gt;极大似然估计用一句话概括就是：知道结果，反推条件θ。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://jintang.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="奇异值分解" scheme="https://jintang.github.io/tags/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法—降维算法—PCA</title>
    <link href="https://jintang.github.io/2019/08/27/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E2%80%94%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95%E2%80%94PCA/"/>
    <id>https://jintang.github.io/2019/08/27/机器学习算法—降维算法—PCA/</id>
    <published>2019-08-27T06:31:37.000Z</published>
    <updated>2019-08-30T08:19:41.189Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>现实应用中属性维数经常成千上万。而许多学习方法都涉及距离计算，而高维空间会给距离计算带来很大的麻烦，例如当维数很高时甚至连计算内积都不再容易。</p><p>事实上，在高维情形下出现的数据样本稀疏、距离计算困难等问题，是所有机器学习方法共同面临的严重障碍，被称为 <strong>“维数灾难(curse of simensionality)”</strong>。缓解维数灾难的一个重要途径是 <strong>降维(dimension reduction)</strong> , 亦称 ”维数约简“, 即通过某种数学变换将原始高维属性空间转变为一个低维 ”子空间“(subspace)， 在这个子空间中样本密度大幅提高，距离计算也变得更为容易。</p><p>为什么可以降维呢？ 因为很多时候，人们观测或者收集到的数据样本虽然是高维的，但与学习任务密切相关的也许仅是某个低维分布，即高维空间的一个低维 ”嵌入“。例如：数据属性中存在噪声属性、相似属性或冗余属性等，<strong>对高维数据进行降维能在一定程度上达到提炼低维优质属性或降噪的效果。</strong></p><p>在很多算法中，降维算法成为了数据预处理的一部分，如 <code>PCA</code></p></blockquote><h3 id="降维算法简介"><a href="#降维算法简介" class="headerlink" title="降维算法简介"></a>降维算法简介</h3><p>目前已经存在大量的数据降维算法，可以从另个不同的维度对它们进行分类。按照是否有使用样本的标签值，可以将降维算法分为 <strong>有监督降维</strong> 和 <strong>无监督降维</strong> ；按照降维算法使用的映射函数，可以将算法分为 <strong>线性降维</strong> 与 <strong>非线性降维</strong> 。</p><ul><li><strong>无监督降维算法</strong> 不使用样本标签值，因此是一种无监督学习算法，其典型代表是 <code>PCA</code> 。<strong>有监督的降维算法</strong> 则使用了样本标签值，是一种有监督学习算法，其典型代表是 <code>LDA</code></li><li><strong>线性降维算法</strong> 根据样本集构造出线性函数完成向低维空间的映射。一般通过对向量 $x$ 进行线性变换即左乘一个投影矩阵 $W$ 而得到结果向量 $y$ ： $y = Wx$ ， <code>PCA</code> 和 <code>LDA</code> 都是 <strong>线性降维算法</strong> ; 非线性降维算法则构造一个非线性映射完成数据的降维。很多时候数据是非线性的，因此需要使用 <strong>非线性降维算法</strong> 以取得更好的效果，<code>LLE</code> 就是一种 <strong>非线性降维算法</strong></li></ul><p>对于 <strong>线性降维</strong>，我们主要使用 <strong>投影</strong> 的方法。对于 <strong>非线性降维</strong>， 我们主要使用 <strong>流形学习</strong>。<strong>流形学习（manifold learning）</strong> 是一种借助拓扑流形概念的降维方法，流形是指在局部与欧式空间同胚的空间，即在局部与欧式空间具有相同的性质，能用欧氏距离计算样本之间的距离。这样即使高维空间的分布十分复杂，但是在局部上依然满足欧式空间的性质，基于流形学习的降维正是这种 <strong>“邻域保持”</strong> 的思想。可以简单的将流形理解成二维空间的曲线，三维空间的曲面，等几何体在更高维空间的推广。</p><p>有时候， <strong>投影</strong> 并不是降维的最佳方法。在很多情况下，子空间可能会扭曲和转动，比如图所示的著名的瑞士卷数据集：<br><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/swiss_roll_data.jpeg" alt="swiss_roll_data"><br>简单地将数据集投射到一个平面上会将瑞士卷的不同层叠在一起，如图左侧所示。但是，你真正想要的是展开瑞士卷所获取到的类似图右侧的 2D 数据集。这时候就需要使用 <strong>流形学习</strong>。<br><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/swill_roll_reduce.jpeg" alt="swill_roll_reduce"></p><p>所以采用哪种方式降维，这一切都取决于数据集。</p><p>大概介绍一下几个比较出名的降维算法： <code>PCA</code> 、 <code>LDA</code> 、 <code>LLE</code></p><a id="more"></a><ul><li><p><code>PCA</code> ，Principle Component Analysis，即主成分分析法，是特征降维的最常用手段，是最基础的 <strong>无监督降维算法</strong> 。顾名思义， <code>PCA</code> 能从冗余特征中提取主要成分，在不太损失模型质量的情况下，提升了模型训练速度。</p><p>它的目标是通过某种线性投影，将高维的数据映射到低维的空间中表示，并期望在所投影的维度上数据的方差最大，以此使用较少的数据维度，同时保留住较多的原数据点的特性。</p><p>通俗的理解，如果把所有的点都映射到一起，那么几乎所有的信息（如点和点之间的距离关系）都丢失了，而如果映射后方差尽可能的大，那么数据点则会分散开来，以此来保留更多的信息。可以证明，PCA是丢失原始数据信息最少的一种线性降维方式。如图：<br><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/pca_compare.jpeg" alt="pca_compare"><br>正如我们所看到的，投影到实线上保留了 <strong>最大方差</strong>。选择保持 <strong>最大方差</strong> 的轴看起来是合理的，因为它很可能比其他投影损失更少的信息。证明这种选择的另一种方法是，选择这个轴使得将原始数据集投影到该轴上的均方距离最小。这两种做法对应了 <code>PCA</code> 的两种性质，而且得到了相同的结果。</p></li><li><code>LDA</code> ， 线性判别分析, 一种 <strong>有监督的线性降维算法</strong> 。其基本思想是：将训练样本投影到一条直线上，使得同类的样例尽可能近，不同类的样例尽可能远。如图所示：<br><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/lda.png" alt="lda"><br>对新的样本进行分类时，只需将该样本点投影到这条直线上，根据与各个类别的中心值进行比较，从而判定出新样本与哪个类别距离最近。</li><li><code>LLE</code> , manifold learning , 即局部线性嵌入。是一种经典的 <strong>流形学习</strong> 算法。它的目标是 保持邻域内样本之间的线性关系。</li></ul><p>降维除了可以加快训练速度外，在数据可视化方面也十分有用。降低特征维度到 2（或者 3）维从而可以在图中画出一个高维度的训练集，让我们可以通过视觉直观的发现一些非常重要的信息，比如 <strong>聚类</strong>。</p><h3 id="PCA算法原理"><a href="#PCA算法原理" class="headerlink" title="PCA算法原理"></a>PCA算法原理</h3><p><code>主成分分析（PCA）</code> 直接通过一个线性变换，将原始空间中的样本投影到新的低维空间中。简单来理解这一过程便是： <code>PCA</code> 采用一组新的基来表示样本点，其中每一个基向量都是原来基向量的线性组合，通过使用尽可能少的新基向量来表出样本，从而达到降维的目的。</p><p>根据 <code>PCA</code> 的目标，它有这两个重要的性质：</p><ul><li>最近重构性：样本点到超平面的距离足够近，即尽可能在超平面附近；</li><li>最大可分性：样本点在超平面上的投影尽可能地分散开来，即投影后的坐标具有区分性。满足上面所说的 <strong>最大方差理论</strong> 。</li></ul><p>举个例子：假设我们要将特征从 n 维度降到 k 维：PCA 首先找寻 k 个 n 维向量，然后将特征投影到这些向量构成的 k 维空间，并保证投影误差足够小。下图中中，为了将特征维度从三维降低到二位，PCA 就会先找寻两个三维向量 $u^{(1)}$ , $u^{(2)}$ ，二者构成了一个二维平面，然后将原来的三维特征投影到该二维平面上：<br><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/PCA3D22D.png" alt="pca3d22d"></p><h4 id="PCA算法步骤"><a href="#PCA算法步骤" class="headerlink" title="PCA算法步骤"></a>PCA算法步骤</h4><p><strong>最近重构性与最大可分性虽然从不同的出发点来定义优化问题中的目标函数，但最终这两种特性得到了完全相同的优化问题。</strong> 所以可以得到以下推导：<br><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/pca_derivation.png" alt="pca_derivation"><br>接着使用拉格朗日乘子法求解上面的优化问题，得到：<br><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/pca_fangcha.png" alt="pca_xiefangcha"><br>因此只需对协方差矩阵进行特征值分解即可求解出投影矩阵 $W$ ，<code>PCA</code> 算法的整个流程如下图所示：<br><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/pca-progress.png" alt="pca-progress"><br>所以我们的新样本是：<br>$$Z = XW$$</p><blockquote><p><strong>直观点的例子：</strong></p><ol><li>原始数据集矩阵 X：<br>$$\left[ \begin{array}{cc} 1 &amp; 1 &amp; 2 &amp; 4 &amp; 2 \\ 1 &amp; 3 &amp; 3 &amp; 4 &amp; 4 \end{array} \right]$$</li><li>中心化后：<br>$$\left[ \begin{array}{cc} -1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \\ -2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \end{array} \right]$$</li><li>再求协方差矩阵：<br>$$C = \frac15\left[ \begin{array}{cc} -1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \\ -2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \end{array} \right]\left[ \begin{array}{cc} -1 &amp; -2 \\ -1 &amp; 0 \\ 0 &amp; 0 \\ 2 &amp; 1 \\ 0 &amp; 1 \end{array} \right] = \left[ \begin{array}{cc} \frac65 &amp; \frac45 \\ \frac45 &amp; \frac65 \end{array} \right]$$</li><li>特征值：<br>$$λ_1 = 2, λ_2 = \frac25 $$</li><li>对应的特征向量:<br>$$c1 = \left[ \begin{array}{cc} \frac{1}{\sqrt2} \\ \frac{1}{\sqrt2} \end{array} \right], c2 = \left[ \begin{array}{cc} -\frac{1}{\sqrt2} \\ \frac{1}{\sqrt2} \end{array} \right]$$</li><li>标准化：<br>$$P = \left[ \begin{array}{cc} \frac{1}{\sqrt2} &amp; \frac{1}{\sqrt2} \\ -\frac{1}{\sqrt2} &amp; \frac{1}{\sqrt2} \end{array} \right]$$</li><li>选择较大特征值对应的特征向量：<br>$$W = \left[ \begin{array}{cc} \frac{1}{\sqrt2} &amp; \frac{1}{\sqrt2} \end{array} \right]$$</li><li>执行 <code>PCA</code> 变换：$Z=WX$ 得到的 Z 就是 <code>PCA</code> 降维后的值 数据集矩阵:<br>$$Z = \left[ \begin{array}{cc} \frac{1}{\sqrt2} &amp; \frac{1}{\sqrt2} \end{array} \right]\left[ \begin{array}{cc} -1 &amp; -1 &amp; 0 &amp; 2 &amp; 0 \\ -2 &amp; 0 &amp; 0 &amp; 1 &amp; 1 \end{array} \right] = \left[ \begin{array}{cc} -\frac{1}{\sqrt2} &amp; -\frac{1}{\sqrt2} &amp; 0 &amp; \frac{3}{\sqrt2} &amp; \frac{1}{\sqrt2} \end{array} \right]$$</li></ol></blockquote><h4 id="PCA-降维后的恢复"><a href="#PCA-降维后的恢复" class="headerlink" title="PCA 降维后的恢复"></a>PCA 降维后的恢复</h4><p>通过上面的步骤将数据进行了压缩，同样，可以通过逆向流程来恢复数据。由于：<br>$$Z=XW$$<br>因此：<br>$$X_{approx}=ZW^T$$<br>之所以用 Xapprox，是因为恢复后的数据会有一定的误差。如下图所示，左边为原始数据，右边为恢复后的数据。<br><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/pca-recover.svg" alt="pca-recover"></p><h4 id="PCA-降到多少维才合适？"><a href="#PCA-降到多少维才合适？" class="headerlink" title="PCA 降到多少维才合适？"></a>PCA 降到多少维才合适？</h4><p>从 <code>PCA</code> 的执行流程中，我们知道，需要为 <code>PCA</code> 指定目的维度 $d’$ 。如果降维不多，则性能提升不大；如果目标维度太小，则又丢失了许多信息。</p><p>降维后低维空间的维数 $d’$ 通常由用户先指定， 或通过在 $d’$ 值不同的低维空间中对 <strong>$k$ 近邻分类器</strong>（或其他开销较小的学习算法） 进行交叉验证来选取较好的 $d’$ 值。对 <code>PCA</code> ，还可以从重构的角度来设置一个重构阈值，例如 $t = 95\% $ ，然后选择使得下式成立的最小的 $d’$ 值：</p><p><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/d_formula.png" alt="d_formula"></p><h4 id="PCA-的作用和效果"><a href="#PCA-的作用和效果" class="headerlink" title="PCA 的作用和效果"></a>PCA 的作用和效果</h4><p>显然，低维空间和原始高维空间必有不同，因为对应于最小的 $d - d’$ 个特征值的特征向量被舍弃了，这是降维导致的结果。但舍弃这一部分信息往往是必要的： 一方面，舍弃这部分信息后使得样本的采样密度增大，这是降维的重要动机；另一方面，当数据收到噪声影响时，最小的特征值所对应的特征向量往往与噪声有关，将他们舍弃能在一定程度上起到去噪的作用。</p><h3 id="PCA算法实例"><a href="#PCA算法实例" class="headerlink" title="PCA算法实例"></a>PCA算法实例</h3><p>首先我们利用 <strong>奇异值分解</strong> 实现一个 <code>pca</code> 算法，我们也可以直接使用 <a href="https://scikit-learn.org/stable/modules/generated/sklearn.decomposition.PCA.html#sklearn.decomposition.PCA" target="_blank" rel="noopener">Scikit-Learn 的 PCA 类</a>，以供后面的实例使用， 代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf8</span></span><br><span class="line"><span class="comment"># pca/pca.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">normalize</span><span class="params">(X)</span>:</span></span><br><span class="line">    <span class="string">"""数据标准化处理</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        X 样本</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        XNorm 标准化后的样本</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    XNorm = X.copy()</span><br><span class="line">    m,n = XNorm.shape</span><br><span class="line">    mean = np.mean(XNorm, axis=<span class="number">0</span>)</span><br><span class="line">    std = np.std(XNorm, axis=<span class="number">0</span>)</span><br><span class="line">    XNorm = (XNorm - mean) / std</span><br><span class="line">    <span class="keyword">return</span> XNorm</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PCA</span><span class="params">(X, k = <span class="number">1</span>)</span>:</span></span><br><span class="line">    <span class="string">"""PCA</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        X 样本</span></span><br><span class="line"><span class="string">        k 目的维度</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        XNorm 标准化后的样本</span></span><br><span class="line"><span class="string">        Z 降维后的新样本</span></span><br><span class="line"><span class="string">        U U</span></span><br><span class="line"><span class="string">        UReduce 约减矩阵  Ureduce，即投影矩阵</span></span><br><span class="line"><span class="string">        S S</span></span><br><span class="line"><span class="string">        V V</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    m, n = X.shape</span><br><span class="line">    <span class="comment"># 数据中心化</span></span><br><span class="line">    XNorm = normalize(X)</span><br><span class="line">    <span class="comment"># 计算协方差矩阵</span></span><br><span class="line">    Coef = XNorm.T * XNorm/m</span><br><span class="line">    <span class="comment"># 奇异值分解</span></span><br><span class="line">    U, S, V = np.linalg.svd(Coef)</span><br><span class="line">    <span class="comment"># 取出前 k 个向量</span></span><br><span class="line">    UReduce = U[:, <span class="number">0</span>:k]</span><br><span class="line">    Z = XNorm * UReduce</span><br><span class="line">    <span class="keyword">return</span> XNorm, Z, U, UReduce, S, V</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recover</span><span class="params">(UReduce, Z)</span>:</span></span><br><span class="line">    <span class="string">"""数据恢复</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        UReduce 约减矩阵  Ureduce，即投影矩阵</span></span><br><span class="line"><span class="string">        Z 降维后的样本</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> Z * UReduce.T</span><br></pre></td></tr></table></figure><h4 id="PCA-for-加速学习"><a href="#PCA-for-加速学习" class="headerlink" title="PCA for 加速学习"></a>PCA for 加速学习</h4><p>现在，我们手上有一个人脸数据集，每张图片大小为 32×32 ，以像素为特征，则每个特征向量的维度就为 1024 维：</p><p><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/face_before_pca.png" alt="face_before_pca"></p><p>使用 <code>PCA</code> 进行降低特征维度到 100 维：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf8</span></span><br><span class="line"><span class="comment"># pca/test_pca4visualization.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pca</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(images, width, height)</span>:</span></span><br><span class="line">    <span class="string">"""展示图片</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        images 图像样本</span></span><br><span class="line"><span class="string">        width 图像宽</span></span><br><span class="line"><span class="string">        height 图像高</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    m, n = images.shape</span><br><span class="line">    rows = int(np.floor(np.sqrt(m)))</span><br><span class="line">    cols = int(np.ceil(m / rows))</span><br><span class="line">    <span class="comment"># 图像拼接</span></span><br><span class="line">    dstImage = images.copy()</span><br><span class="line">    dstImage = np.zeros((rows * height, cols * width))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(rows):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(cols):</span><br><span class="line">            idx = cols * i + j</span><br><span class="line">            image = images[idx].reshape(height, width)</span><br><span class="line">            dstImage[i * height:i * height + height,</span><br><span class="line">                     j * width: j * width + width] = image</span><br><span class="line">    plt.imshow(dstImage.T, cmap=<span class="string">'gray'</span>)</span><br><span class="line">    plt.axis(<span class="string">'off'</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">data = loadmat(<span class="string">'data/ex7faces.mat'</span>)</span><br><span class="line">X = np.mat(data[<span class="string">'X'</span>],dtype=np.float32)</span><br><span class="line">m, n = X.shape</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示原图</span></span><br><span class="line">display(X[<span class="number">0</span>:<span class="number">100</span>, :], <span class="number">32</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">XNorm, Z, U, UReduce, S, V = pca.PCA(X, k=<span class="number">100</span>)</span><br><span class="line">XRec = pca.recover(UReduce, Z)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示修复后的图，可以看出，PCA 损失了一部分细节</span></span><br><span class="line">display(XRec[<span class="number">0</span>:<span class="number">100</span>, :], <span class="number">32</span>, <span class="number">32</span>)</span><br></pre></td></tr></table></figure><p>结果如下, 可以看到，我们的人脸数据变得模糊，但是眼睛，鼻子，嘴唇等特征仍然可辨识：</p><p><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/face_after_pca.png" alt="face_after_pca"></p><h4 id="PCA-for-数据可视化"><a href="#PCA-for-数据可视化" class="headerlink" title="PCA for 数据可视化"></a>PCA for 数据可视化</h4><p>我们有一张小鸟的图片，这是一个三通道彩色图像：</p><p><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/bird_small.png" alt="bird"></p><p>我们将图片的像素按颜色进行聚类，并在三维空间观察聚类成果：</p><p><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/3D_data.png" alt="3d_data"></p><p>似乎在三维空间可视化不是那么直观，借助于 <code>PCA</code> ，我们将聚类结果降到二维空间进行可视化：</p><p><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/2D_data.png" alt="2d_data"></p><p>示例代码：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf8</span></span><br><span class="line"><span class="comment"># pca/test_pca4visualization.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> kmeans</span><br><span class="line"><span class="keyword">import</span> pca</span><br><span class="line"><span class="keyword">from</span> scipy.io <span class="keyword">import</span> loadmat</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.cm <span class="keyword">as</span> cmx</span><br><span class="line"><span class="keyword">import</span> matplotlib.colors <span class="keyword">as</span> colors</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getCmap</span><span class="params">(count)</span>:</span></span><br><span class="line">    color_norm  = colors.Normalize(vmin=<span class="number">0</span>, vmax=count<span class="number">-1</span>)</span><br><span class="line">    scalar_map = cmx.ScalarMappable(norm=color_norm, cmap=<span class="string">'hsv'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">map_index_to_rgb_color</span><span class="params">(index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> scalar_map.to_rgba(index)</span><br><span class="line">    <span class="keyword">return</span> map_index_to_rgb_color</span><br><span class="line"></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>, projection=<span class="string">'3d'</span>)</span><br><span class="line"></span><br><span class="line">data = loadmat(<span class="string">'data/bird_small.mat'</span>)</span><br><span class="line">A = data[<span class="string">'A'</span>]</span><br><span class="line"></span><br><span class="line">A = A / <span class="number">255.0</span>;</span><br><span class="line"></span><br><span class="line">height, width, channels = A.shape</span><br><span class="line">X = np.mat(A.reshape(height * width, channels))</span><br><span class="line"></span><br><span class="line">m, n = X.shape</span><br><span class="line"></span><br><span class="line">clusterNum = <span class="number">16</span></span><br><span class="line">cmap = getCmap(clusterNum)</span><br><span class="line">centroids, clusterAssment = kmeans.kMeans(X, clusterNum)</span><br><span class="line"><span class="comment"># 随机选择 1000 个样本绘制</span></span><br><span class="line">sampleSize = <span class="number">1000</span></span><br><span class="line">sampleIndexs = np.random.choice(m, sampleSize)</span><br><span class="line">clusters = clusterAssment[sampleIndexs]</span><br><span class="line">samples = X[sampleIndexs]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三维下观察</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(sampleSize):</span><br><span class="line">    x, y, z = samples[i,:].A[<span class="number">0</span>]</span><br><span class="line">    center = clusters[i, <span class="number">0</span>]</span><br><span class="line">    color = cmap(center)</span><br><span class="line">    ax.scatter([x], [y], [z], color=color, marker=<span class="string">'o'</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维下观察</span></span><br><span class="line">reducedSamples = pca.PCA(samples, k=<span class="number">2</span>)[<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(sampleSize):</span><br><span class="line">    x, y = reducedSamples[i,:].A[<span class="number">0</span>]</span><br><span class="line">    center = clusters[i, <span class="number">0</span>]</span><br><span class="line">    color = cmap(center)</span><br><span class="line">    plt.scatter([x], [y], color=color, marker=<span class="string">'o'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p></p><h3 id="PCA-引申"><a href="#PCA-引申" class="headerlink" title="PCA 引申"></a>PCA 引申</h3><p>线性降维方法假设聪高维空间到低维空间的函数映射都是线性的，然而，在不少现实任务中，可能需要非线性映射才能找到恰当的低维嵌入。例如：<br><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/pca_k.png" alt="pca_k"><br>如上所示，如果直接使用线性降维方法对三维空间观察到的样本点进行降维，则将丢失原本的低维结构，我们需要的是 “本真二维结构”</p><p>在上面我们提到了 <strong>流形学习</strong> ，这儿我们还有另外一种方法，基于核技巧对线性降维方法进行 <strong>”核化“</strong> ，其实即先将样本映射到高维空间，再在高维空间中使用线性降维的方法。</p><p><code>PCA</code> 可以通过 <strong>核化</strong> 生成 <strong>核主成分分析（KPCA）</strong> ，它通常能够很好地保留投影后的簇，有时甚至可以展开分布近似于扭曲流形的数据集。</p><p>下图 展示了使用线性核， <code>RBF</code> 核， <code>sigmoid</code> 核 将瑞士卷降到 2 维。<br><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/kpca.jpeg" alt="kpca"></p><p>选择最佳的 <strong>核方法</strong> 和 <strong>超参数值</strong> 是另外一部分复杂的部分，这儿简单带过，感兴趣的同学自己研究下。</p><blockquote><p><strong>参考链接：</strong></p><ul><li><a href="https://yoyoyohamapi.gitbooks.io/mit-ml/content/%E7%89%B9%E5%BE%81%E9%99%8D%E7%BB%B4/articles/PCA.html" target="_blank" rel="noopener">斯坦福机器学习笔记</a></li><li><a href="https://github.com/Vay-keen/Machine-learning-learning-notes" target="_blank" rel="noopener">周志华《机器学习》学习笔记</a></li></ul></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;现实应用中属性维数经常成千上万。而许多学习方法都涉及距离计算，而高维空间会给距离计算带来很大的麻烦，例如当维数很高时甚至连计算内积都不再容易。&lt;/p&gt;&lt;p&gt;事实上，在高维情形下出现的数据样本稀疏、距离计算困难等问题，是所有机器学习方法共同面临的严重障碍，被称为 &lt;strong&gt;“维数灾难(curse of simensionality)”&lt;/strong&gt;。缓解维数灾难的一个重要途径是 &lt;strong&gt;降维(dimension reduction)&lt;/strong&gt; , 亦称 ”维数约简“, 即通过某种数学变换将原始高维属性空间转变为一个低维 ”子空间“(subspace)， 在这个子空间中样本密度大幅提高，距离计算也变得更为容易。&lt;/p&gt;&lt;p&gt;为什么可以降维呢？ 因为很多时候，人们观测或者收集到的数据样本虽然是高维的，但与学习任务密切相关的也许仅是某个低维分布，即高维空间的一个低维 ”嵌入“。例如：数据属性中存在噪声属性、相似属性或冗余属性等，&lt;strong&gt;对高维数据进行降维能在一定程度上达到提炼低维优质属性或降噪的效果。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;在很多算法中，降维算法成为了数据预处理的一部分，如 &lt;code&gt;PCA&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;降维算法简介&quot;&gt;&lt;a href=&quot;#降维算法简介&quot; class=&quot;headerlink&quot; title=&quot;降维算法简介&quot;&gt;&lt;/a&gt;降维算法简介&lt;/h3&gt;&lt;p&gt;目前已经存在大量的数据降维算法，可以从另个不同的维度对它们进行分类。按照是否有使用样本的标签值，可以将降维算法分为 &lt;strong&gt;有监督降维&lt;/strong&gt; 和 &lt;strong&gt;无监督降维&lt;/strong&gt; ；按照降维算法使用的映射函数，可以将算法分为 &lt;strong&gt;线性降维&lt;/strong&gt; 与 &lt;strong&gt;非线性降维&lt;/strong&gt; 。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;无监督降维算法&lt;/strong&gt; 不使用样本标签值，因此是一种无监督学习算法，其典型代表是 &lt;code&gt;PCA&lt;/code&gt; 。&lt;strong&gt;有监督的降维算法&lt;/strong&gt; 则使用了样本标签值，是一种有监督学习算法，其典型代表是 &lt;code&gt;LDA&lt;/code&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;线性降维算法&lt;/strong&gt; 根据样本集构造出线性函数完成向低维空间的映射。一般通过对向量 $x$ 进行线性变换即左乘一个投影矩阵 $W$ 而得到结果向量 $y$ ： $y = Wx$ ， &lt;code&gt;PCA&lt;/code&gt; 和 &lt;code&gt;LDA&lt;/code&gt; 都是 &lt;strong&gt;线性降维算法&lt;/strong&gt; ; 非线性降维算法则构造一个非线性映射完成数据的降维。很多时候数据是非线性的，因此需要使用 &lt;strong&gt;非线性降维算法&lt;/strong&gt; 以取得更好的效果，&lt;code&gt;LLE&lt;/code&gt; 就是一种 &lt;strong&gt;非线性降维算法&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;对于 &lt;strong&gt;线性降维&lt;/strong&gt;，我们主要使用 &lt;strong&gt;投影&lt;/strong&gt; 的方法。对于 &lt;strong&gt;非线性降维&lt;/strong&gt;， 我们主要使用 &lt;strong&gt;流形学习&lt;/strong&gt;。&lt;strong&gt;流形学习（manifold learning）&lt;/strong&gt; 是一种借助拓扑流形概念的降维方法，流形是指在局部与欧式空间同胚的空间，即在局部与欧式空间具有相同的性质，能用欧氏距离计算样本之间的距离。这样即使高维空间的分布十分复杂，但是在局部上依然满足欧式空间的性质，基于流形学习的降维正是这种 &lt;strong&gt;“邻域保持”&lt;/strong&gt; 的思想。可以简单的将流形理解成二维空间的曲线，三维空间的曲面，等几何体在更高维空间的推广。&lt;/p&gt;&lt;p&gt;有时候， &lt;strong&gt;投影&lt;/strong&gt; 并不是降维的最佳方法。在很多情况下，子空间可能会扭曲和转动，比如图所示的著名的瑞士卷数据集：&lt;br&gt;&lt;img src=&quot;https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/swiss_roll_data.jpeg&quot; alt=&quot;swiss_roll_data&quot;&gt;&lt;br&gt;简单地将数据集投射到一个平面上会将瑞士卷的不同层叠在一起，如图左侧所示。但是，你真正想要的是展开瑞士卷所获取到的类似图右侧的 2D 数据集。这时候就需要使用 &lt;strong&gt;流形学习&lt;/strong&gt;。&lt;br&gt;&lt;img src=&quot;https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/machine-learn/swill_roll_reduce.jpeg&quot; alt=&quot;swill_roll_reduce&quot;&gt;&lt;/p&gt;&lt;p&gt;所以采用哪种方式降维，这一切都取决于数据集。&lt;/p&gt;&lt;p&gt;大概介绍一下几个比较出名的降维算法： &lt;code&gt;PCA&lt;/code&gt; 、 &lt;code&gt;LDA&lt;/code&gt; 、 &lt;code&gt;LLE&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://jintang.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="降维算法" scheme="https://jintang.github.io/tags/%E9%99%8D%E7%BB%B4%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Service Workers 简单实例与学习</title>
    <link href="https://jintang.github.io/2019/07/12/Service-Workers-%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B%E4%B8%8E%E5%AD%A6%E4%B9%A0/"/>
    <id>https://jintang.github.io/2019/07/12/Service-Workers-简单实例与学习/</id>
    <published>2019-07-12T08:41:15.000Z</published>
    <updated>2019-08-20T02:08:08.736Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>Service Workers</code> 可以让你的网页在离线模式下访问。 附几个链接：</p><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers" target="_blank" rel="noopener">Service Workers 使用文档</a></li><li><a href="https://developers.google.com/web/tools/workbox/guides/get-started" target="_blank" rel="noopener">Workbox</a>：快速构建 <code>Service Workers</code> 的工具</li><li><a href="https://medium.com/google-developer-experts/a-5-minute-intro-to-workbox-3-0-156803952b3e" target="_blank" rel="noopener">A 5 minute intro to Workbox 3.0</a></li></ul></blockquote><h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><ul><li>目前有的浏览器还不支持，比如 <code>IE</code> … 使用前请用 <a href="https://caniuse.com/#search=service%20worker" target="_blank" rel="noopener">caniuse</a> 查询支持情况</li><li><code>https</code> 的页面才支持。为了调试，本地 <code>localhost</code> 也可以</li></ul><p>通过观察拥有 <code>Service Workers</code> 的网站，比如说 <a href="https://996.icu" target="_blank" rel="noopener">996.ICU</a> ,通过打开 <strong>Chrome dev tools =&gt; Application =&gt; Service Workers</strong> 选项，可以看到这个网站注册了一个 <code>Service Workers</code>， 它使用的源文件是 <a href="https://996.icu/service-worker.js" target="_blank" rel="noopener">service-worker.js</a> ，点击打开可以看到里面的代码，这个很简单，而且使用 <code>workbox</code> 生成的。</p><p>其实我们的浏览器会记录所有访问过的网站里面有 <code>Service Workers</code> 的。在上面的调试窗口下，可以看到 <strong>996.icu</strong> 下面还有一个 <strong>Service workers from other domains</strong> 的选项，打开就可以看到其他使用 <code>Service Workers</code> 的网站了。我看了我访问过的那些网站， 除了 <a href="https://lodash.com/sw.js" target="_blank" rel="noopener">lodash 的 sw.js</a> 不知道用什么生成的外，其他的都用的是 <code>workbox</code> 生成的。</p><p>下面简单说一下步骤，简单明了，保证你一看就会。就以 <a href="https://github.com/jintangWang/frontend-nanodegree-mobile-portfolio" target="_blank" rel="noopener">frontend-nanodegree-mobile-portfolio</a>（这是上一篇博文<a href="https://jintang.github.io/2019/07/02/%E7%BD%91%E9%A1%B5%E5%85%B3%E9%94%AE%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84/">网页关键渲染路径</a>中的实例仓库） 为例</p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install workbox-cli --<span class="built_in">save</span>-<span class="built_in">dev</span></span><br></pre></td></tr></table></figure><h3 id="生成配置文件"><a href="#生成配置文件" class="headerlink" title="生成配置文件"></a>生成配置文件</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">npx workbox wizard</span></span><br></pre></td></tr></table></figure><p>这个命令会产生交互式的操作，询问你要缓存的文件：<br><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/workbox-wizard.png" alt="workbox-wizard"><br>在填写完之后会在根目录生成一个 <code>workbox-config.js</code>， 里面就是你选择的内容</p><h3 id="生成-sw-js"><a href="#生成-sw-js" class="headerlink" title="生成 sw.js"></a>生成 sw.js</h3><p>从上图可以看到，命令行提示你输入<br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">workbox</span> <span class="selector-tag">generateSW</span> <span class="selector-tag">workbox-config</span><span class="selector-class">.js</span></span><br></pre></td></tr></table></figure><p></p><p>然后再 <code>dist/</code> 目录下就会多出一个 <code>sw.js</code> ，这就是我们需要的。</p><h3 id="注册-service-worker"><a href="#注册-service-worker" class="headerlink" title="注册 service worker"></a>注册 service worker</h3><p>在 <code>index.html</code> 下添加如下代码， 因为我 <code>dist/</code> 目录下的文件都是由 <code>src/</code> 下的文件生成的，所以我修改的是 <code>src/</code> 下的 <code>index.html</code> 并重新打包<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span></span><br><span class="line"><span class="javascript">   <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, () =&gt; &#123;</span></span><br><span class="line"><span class="actionscript">      navigator.serviceWorker.register(<span class="string">'/sw.js'</span>);</span></span><br><span class="line"><span class="undefined">   &#125;);</span></span><br><span class="line"><span class="undefined"> &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><h3 id="部署并访问"><a href="#部署并访问" class="headerlink" title="部署并访问"></a>部署并访问</h3><p>本地启动服务测试一下，因为我这只是简单的静态页面，所以我用 <a href="http://www.browsersync.cn/" target="_blank" rel="noopener">Browsersync</a> 工具启动服务。</p><p><code>dist/</code> 目录下运行以下命令<br></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">browser-sync</span> <span class="selector-tag">start</span> <span class="selector-tag">--server</span> <span class="selector-tag">--files</span> "**<span class="comment">/*.css, **/</span>*<span class="selector-class">.html</span>, *<span class="selector-class">.html</span>"</span><br></pre></td></tr></table></figure><p></p><p>关闭网络后刷新页面，页面还是可以访问，说明缓存成功。</p><p>将这些代码重新部署到服务器上进行访问，这儿我用的是 <code>github pages</code> ，正好有 <code>https</code>。</p><p>在 <strong>Chrome dev tools =&gt; Network</strong> 下可以看到很多带有 ⚙️ 图标的请求，这些都是 <code>Service Workers</code> 的请求，同时可以在<strong>Chrome dev tools =&gt; Application =&gt; Service Workers</strong> 下看到当前网站注册的 <code>Service Workers</code>。</p><p><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/service-worker-result.png" alt="service worker result"></p><p>最后附上该实例的 <a href="https://jintangwang.github.io/frontend-nanodegree-mobile-portfolio/dist/" target="_blank" rel="noopener">地址</a></p><h3 id="添加自己的-sw-js-的代码"><a href="#添加自己的-sw-js-的代码" class="headerlink" title="添加自己的 sw.js 的代码"></a>添加自己的 <code>sw.js</code> 的代码</h3><p>上面我们的 <code>sw.js</code> 是由命令行生成的。如果我们想添加点自己的代码，直接修改 <code>sw.js</code> 是不行的，因为每次重新运行命令行都会重新生成。做法如下：</p><ol><li><p>创建 <code>src-sw.js</code>,如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">importScripts(<span class="string">"https://storage.googleapis.com/workbox-cdn/releases/4.3.1/workbox-sw.js"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己的代码开始...</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'this is my custom service worker'</span>); </span><br><span class="line"><span class="comment">// 自己的代码结束...</span></span><br><span class="line"></span><br><span class="line">workbox.precaching.precacheAndRoute([]);</span><br></pre></td></tr></table></figure></li><li><p>在 <code>workbox-config.js</code> 底部添加一行;</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"swSrc"</span>: <span class="string">"src-sw.js"</span></span><br></pre></td></tr></table></figure></li><li><p>运行命令将预缓存的资源数组注入：</p><pre><code class="js"><span class="comment">// 会注入到我们写的 workbox.precaching.precacheAndRoute([]);</span>
<span class="comment">// 不能使用 workbox generateSW workbox-config.js 语句生成 sw.js 了。</span>
npx workbox injectManifest
</code></pre></li></ol><p>重新查看 <code>sw.js</code> 即可看到里面既有自己的代码，也有生成的关于缓存的代码。</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>如果要缓存 <code>api</code> 请求，要使用 <code>workbox.routing.registerRoute()</code> 。此处不再详述。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;&lt;code&gt;Service Workers&lt;/code&gt; 可以让你的网页在离线模式下访问。 附几个链接：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Service Workers 使用文档&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://developers.google.com/web/tools/workbox/guides/get-started&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Workbox&lt;/a&gt;：快速构建 &lt;code&gt;Service Workers&lt;/code&gt; 的工具&lt;/li&gt;&lt;li&gt;&lt;a href=&quot;https://medium.com/google-developer-experts/a-5-minute-intro-to-workbox-3-0-156803952b3e&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;A 5 minute intro to Workbox 3.0&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;前情提要&quot;&gt;&lt;a href=&quot;#前情提要&quot; class=&quot;headerlink&quot; title=&quot;前情提要&quot;&gt;&lt;/a&gt;前情提要&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;目前有的浏览器还不支持，比如 &lt;code&gt;IE&lt;/code&gt; … 使用前请用 &lt;a href=&quot;https://caniuse.com/#search=service%20worker&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;caniuse&lt;/a&gt; 查询支持情况&lt;/li&gt;&lt;li&gt;&lt;code&gt;https&lt;/code&gt; 的页面才支持。为了调试，本地 &lt;code&gt;localhost&lt;/code&gt; 也可以&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;通过观察拥有 &lt;code&gt;Service Workers&lt;/code&gt; 的网站，比如说 &lt;a href=&quot;https://996.icu&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;996.ICU&lt;/a&gt; ,通过打开 &lt;strong&gt;Chrome dev tools =&amp;gt; Application =&amp;gt; Service Workers&lt;/strong&gt; 选项，可以看到这个网站注册了一个 &lt;code&gt;Service Workers&lt;/code&gt;， 它使用的源文件是 &lt;a href=&quot;https://996.icu/service-worker.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;service-worker.js&lt;/a&gt; ，点击打开可以看到里面的代码，这个很简单，而且使用 &lt;code&gt;workbox&lt;/code&gt; 生成的。&lt;/p&gt;&lt;p&gt;其实我们的浏览器会记录所有访问过的网站里面有 &lt;code&gt;Service Workers&lt;/code&gt; 的。在上面的调试窗口下，可以看到 &lt;strong&gt;996.icu&lt;/strong&gt; 下面还有一个 &lt;strong&gt;Service workers from other domains&lt;/strong&gt; 的选项，打开就可以看到其他使用 &lt;code&gt;Service Workers&lt;/code&gt; 的网站了。我看了我访问过的那些网站， 除了 &lt;a href=&quot;https://lodash.com/sw.js&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lodash 的 sw.js&lt;/a&gt; 不知道用什么生成的外，其他的都用的是 &lt;code&gt;workbox&lt;/code&gt; 生成的。&lt;/p&gt;&lt;p&gt;下面简单说一下步骤，简单明了，保证你一看就会。就以 &lt;a href=&quot;https://github.com/jintangWang/frontend-nanodegree-mobile-portfolio&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;frontend-nanodegree-mobile-portfolio&lt;/a&gt;（这是上一篇博文&lt;a href=&quot;https://jintang.github.io/2019/07/02/%E7%BD%91%E9%A1%B5%E5%85%B3%E9%94%AE%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84/&quot;&gt;网页关键渲染路径&lt;/a&gt;中的实例仓库） 为例&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jintang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="Service Workers" scheme="https://jintang.github.io/tags/Service-Workers/"/>
    
  </entry>
  
  <entry>
    <title>网页关键渲染路径</title>
    <link href="https://jintang.github.io/2019/07/02/%E7%BD%91%E9%A1%B5%E5%85%B3%E9%94%AE%E6%B8%B2%E6%9F%93%E8%B7%AF%E5%BE%84/"/>
    <id>https://jintang.github.io/2019/07/02/网页关键渲染路径/</id>
    <published>2019-07-02T09:29:45.000Z</published>
    <updated>2019-07-10T07:43:16.674Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>详细请阅读 <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/" target="_blank" rel="noopener">google文档</a> ，这儿记录一些关键的总结<br><code>udacity</code> 有个课程也讲得很详细： <a href="https://classroom.udacity.com/courses/ud884" target="_blank" rel="noopener">课程</a></p></blockquote><h3 id="浏览器首次渲染的几个步骤"><a href="#浏览器首次渲染的几个步骤" class="headerlink" title="浏览器首次渲染的几个步骤"></a>浏览器首次渲染的几个步骤</h3><ol><li>处理 <code>HTML</code> 标记并构建 <code>DOM</code> 树。</li><li>处理 <code>CSS</code> 标记并构建 <code>CSSOM</code> 树。</li><li>将 <code>DOM</code> 与 <code>CSSOM</code> 合并成一个渲染树。渲染树不包括不可见的元素（如： <code>header</code> 下所有，<code>display:none;</code> 的元素，但包括 <code>visibility:hidden;</code> 的元素）</li><li>Layout : 根据渲染树来布局，以计算每个节点的几何信息。</li><li>Paint : 将各个节点绘制到屏幕上。</li></ol><p><strong>优化关键渲染路径就是指最大限度缩短执行上述第 1 步至第 5 步耗费的总时间。</strong> 这样一来，就能尽快将内容渲染到屏幕上，此外还能缩短首次渲染后屏幕刷新的时间，即为交互式内容实现更高的刷新率。</p><a id="more"></a><h3 id="检测并分析"><a href="#检测并分析" class="headerlink" title="检测并分析"></a>检测并分析</h3><h4 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h4><ol><li><a href="https://chrome.google.com/webstore/detail/lighthouse/blipmdconlkpinefehnmjammfjpmpbjk" target="_blank" rel="noopener">Lighthouse Chrome 扩展程序</a></li><li><p><code>Navigation Timing API</code>:</p><p>首先了解一下页面加载时的浏览器事件：<br><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/browser-timing.png" alt="浏览器加载过程"><br>几个关键的事件：</p><ul><li><code>domInteractive</code> 表示 DOM 准备就绪的时间点。</li><li><code>domContentLoaded</code> 一般表示 DOM 和 CSSOM 均准备就绪的时间点。(如果没有阻塞解析器的 JavaScript，则 <code>DOMContentLoaded</code> 将在 <code>domInteractive</code> 后立即触发。)</li><li><p><code>domComplete</code> 表示网页及其所有子资源都准备就绪的时间点。</p><p>示例代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Critical Path: Measure<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"style.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">measureCRP</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> t = <span class="built_in">window</span>.performance.timing,</span></span><br><span class="line"><span class="undefined">        interactive = t.domInteractive - t.domLoading,</span></span><br><span class="line"><span class="undefined">        dcl = t.domContentLoadedEventStart - t.domLoading,</span></span><br><span class="line"><span class="undefined">        complete = t.domComplete - t.domLoading;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> stats = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>);</span></span><br><span class="line"><span class="actionscript">        stats.textContent = <span class="string">'interactive: '</span> + interactive + <span class="string">'ms, '</span> +</span></span><br><span class="line"><span class="actionscript">            <span class="string">'dcl: '</span> + dcl + <span class="string">'ms, complete: '</span> + complete + <span class="string">'ms'</span>;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(stats);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">"measureCRP()"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello <span class="tag">&lt;<span class="name">span</span>&gt;</span>web performance<span class="tag">&lt;/<span class="name">span</span>&gt;</span> students!<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"awesome-photo.jpg"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><p>还是看 <a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/analyzing-crp" target="_blank" rel="noopener">google开发文档</a> ，特别详细清晰。</p><h3 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h3><p>当有 block 的资源时， <strong>CRP(Critical Rendering Path)</strong> 如图：<br><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/crp-process.png" alt="crp-progress"></p><p>所以，我们<strong>优化关键渲染路径的常规步骤如下：</strong></p><ol><li>对关键路径进行分析和特性描述，三个关键渲染路径指标：资源数、字节数、长度。</li><li>最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。</li><li>优化关键字节数以缩短下载时间（往返次数，<code>Tcp</code> 会对大文件进行多次往返）。</li><li>优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度。</li></ol><blockquote><p>注意： 这些资源并不是 blocked : images</p></blockquote><h4 id="优化-JavaScript-的使用"><a href="#优化-JavaScript-的使用" class="headerlink" title="优化 JavaScript 的使用"></a>优化 JavaScript 的使用</h4><p>无论我们使用 <code>&lt;script&gt;</code> 标记还是内联 <code>JavaScript</code> 代码段，您都可以期待两者能够以相同方式工作。 在两种情况下，浏览器都会先暂停构建 <code>DOM</code> 并执行脚本，然后才会处理剩余文档。</p><p>由于 <code>JavaScript</code> 还可以操作 <code>CSS</code> ，阻塞解析器的 <code>JavaScript</code> 会强制浏览器等待 <code>CSSOM</code> 构建完成并暂停 <code>DOM</code> 的构建，继而大大延迟首次渲染的时间。 <strong>如果是外部 <code>JavaScript</code> 文件，浏览器必须停下来，等待从磁盘、缓存或远程服务器获取脚本，这就可能给关键渲染路径增加数十至数千毫秒的延迟。</strong></p><p><strong>所以</strong>， <code>JavaScript</code> 资源会阻塞解析器，除非将其标记为 <code>async</code> 或通过专门的 <code>JavaScript</code> 代码段进行添加。</p><ol><li><p>使用异步 <code>JavaScript</code> 资源<br>向某些 <code>script</code> 标记添加异步关键字 <code>async</code> ，如分析工具的 <code>Js</code> 。这样就不会 block <code>DOM</code> 的构建，也不会 block <code>CSSOM</code> 的构建。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"app.js"</span> <span class="attr">async</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在之前没有 <code>async</code> 的时候，我们一般将脚本写在 <code>onload</code> 事件里，这样可以减少 block 的时间。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>延迟解析非必需的 <code>JavaScript</code><br>为了最大限度减少浏览器渲染网页的工作量，应延迟任何非必需的脚本（即对构建首次渲染的可见内容无关紧要的脚本）。</p></li><li>避免运行时间长的 <code>JavaScript</code><br>运行时间长的 <code>JavaScript</code> 会阻止浏览器构建 <code>DOM</code> 、 <code>CSSOM</code> 以及渲染网页，所以任何对首次渲染无关紧要的初始化逻辑和功能都应延后执行。如果需要运行较长的初始化序列，请考虑将其拆分为若干阶段，以便浏览器可以间隔处理其他事件。</li></ol><h4 id="优化-CSS-的使用"><a href="#优化-CSS-的使用" class="headerlink" title="优化 CSS 的使用"></a>优化 CSS 的使用</h4><p><code>CSS</code> 是构建渲染树的必备元素，首次构建网页时， <code>JavaScript</code> 常常受阻于 CSS。确保将任何非必需的 <code>CSS</code> 都标记为非关键资源（例如打印和其他媒体查询），并应确保尽可能减少关键 <code>CSS</code> 的数量，以及尽可能缩短传送时间。</p><ol><li>将 <code>CSS</code> 置于文档 <code>head</code> 标签内<br>尽早在 <code>HTML</code> 文档内指定所有 <code>CSS</code> 资源，以便浏览器尽早发现 <code>&lt;link&gt;</code> 标记并尽早发出 <code>CSS</code> 请求。</li><li>避免使用 <code>CSS import</code><br>一个样式表可以使用 <code>CSS import (@import)</code> 指令从另一样式表文件导入规则。不过，应避免使用这些指令，因为它们会在关键路径中增加往返次数：只有在收到并解析完带有 <code>@import</code> 规则的 <code>CSS</code> 样式表之后，才会发现导入的 <code>CSS</code> 资源。</li><li>内联阻塞渲染的 <code>CSS</code><br>为获得最佳性能，您可能会考虑将关键 <code>CSS</code> 直接内联到 <code>HTML</code> 文档内。这样做不会增加关键路径中的往返次数，并且如果实现得当，在只有 <code>HTML</code> 是阻塞渲染的资源时，可实现“一次往返”关键路径长度。</li><li><p>通过媒体查询减少会 block 首次加载的 <code>CSS</code> 。如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style-print.css"</span> <span class="attr">media</span>=<span class="string">"print"</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样的话， 浏览器仍然会下载两个 <code>CSS</code> 文件，但是首次关键路径渲染不会让 <code>style-print.css</code> block 住， 只有在 <code>print</code> (打印) 时才会渲染 <code>style-print.css</code> ，</p></li></ol><h3 id="综合实例"><a href="#综合实例" class="headerlink" title="综合实例"></a>综合实例</h3><p>这儿有个题目： <a href="https://github.com/udacity/frontend-nanodegree-mobile-portfolio" target="_blank" rel="noopener">udacity/frontend-nanodegree-mobile-portfolio</a></p><p>这是我的作业： <a href="https://github.com/jintangWang/frontend-nanodegree-mobile-portfolio" target="_blank" rel="noopener">jintangWang/frontend-nanodegree-mobile-portfolio</a></p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li>迁徙到 <code>http2</code></li><li><code>webpack</code> 代码拆分</li><li>…</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;详细请阅读 &lt;a href=&quot;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;google文档&lt;/a&gt; ，这儿记录一些关键的总结&lt;br&gt;&lt;code&gt;udacity&lt;/code&gt; 有个课程也讲得很详细： &lt;a href=&quot;https://classroom.udacity.com/courses/ud884&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;课程&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;浏览器首次渲染的几个步骤&quot;&gt;&lt;a href=&quot;#浏览器首次渲染的几个步骤&quot; class=&quot;headerlink&quot; title=&quot;浏览器首次渲染的几个步骤&quot;&gt;&lt;/a&gt;浏览器首次渲染的几个步骤&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;处理 &lt;code&gt;HTML&lt;/code&gt; 标记并构建 &lt;code&gt;DOM&lt;/code&gt; 树。&lt;/li&gt;&lt;li&gt;处理 &lt;code&gt;CSS&lt;/code&gt; 标记并构建 &lt;code&gt;CSSOM&lt;/code&gt; 树。&lt;/li&gt;&lt;li&gt;将 &lt;code&gt;DOM&lt;/code&gt; 与 &lt;code&gt;CSSOM&lt;/code&gt; 合并成一个渲染树。渲染树不包括不可见的元素（如： &lt;code&gt;header&lt;/code&gt; 下所有，&lt;code&gt;display:none;&lt;/code&gt; 的元素，但包括 &lt;code&gt;visibility:hidden;&lt;/code&gt; 的元素）&lt;/li&gt;&lt;li&gt;Layout : 根据渲染树来布局，以计算每个节点的几何信息。&lt;/li&gt;&lt;li&gt;Paint : 将各个节点绘制到屏幕上。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;strong&gt;优化关键渲染路径就是指最大限度缩短执行上述第 1 步至第 5 步耗费的总时间。&lt;/strong&gt; 这样一来，就能尽快将内容渲染到屏幕上，此外还能缩短首次渲染后屏幕刷新的时间，即为交互式内容实现更高的刷新率。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jintang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="优化" scheme="https://jintang.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>flutter 使用 CI 打包</title>
    <link href="https://jintang.github.io/2019/06/03/flutter%20%E4%BD%BF%E7%94%A8%20CI%20%E6%89%93%E5%8C%85/"/>
    <id>https://jintang.github.io/2019/06/03/flutter 使用 CI 打包/</id>
    <published>2019-06-03T02:01:06.000Z</published>
    <updated>2019-08-15T08:32:10.897Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><code>CI</code> (continuous integration) : 持续集成。用来做一些自动化工作，比如程序的打包，单元测试，部署等。</p><ul><li>我最常用的 <code>git</code> 仓库是 <code>Github</code> , <code>Travis CI</code> 对 <code>Github</code> 支持的特别好，使用非常方便。</li><li>公司的仓库在 <code>Gitlab</code> 上， <code>Gitlab</code>自己内部集成了 <code>Gitlab CI</code>。</li></ul><p>本文主要介绍这两种 <code>CI</code> 自动化打包部署 <code>flutter apk</code></p></blockquote><h2 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h2><p><code>Travis CI</code> 与 <code>Github</code> 结合比较紧密，对 <code>GitHub</code> 上的开源Repo是免费的，私有Repo收费。</p><p><code>Travis CI</code> 有两个网址，一个是 <a href="https://travis-ci.org" target="_blank" rel="noopener">travis-ci.org</a> ， 另一个是 <a href="https://travis-ci.com/" target="_blank" rel="noopener">travis-ci.com</a> 。 官方推荐使用 <code>travis-ci.com</code> ， 告诉我们 <code>travis-ci.org</code> 后面会全部迁徙到 <code>travis-ci.com</code> 。 目前在两个网址都可以实现效果，没啥区别，但不能同时使用。</p><p>下面以 <code>travis-ci.org</code> 为例，反正我刚开始用的时候就选了这个，索性 “将错就错”</p><h3 id="激活要运行-CI-的仓库"><a href="#激活要运行-CI-的仓库" class="headerlink" title="激活要运行 CI 的仓库"></a>激活要运行 CI 的仓库</h3><p>使用 <code>github</code> 账号登录 <code>travis-ci.org</code> ， 在个人设置中心可以看到自己在 <code>github</code> 上的仓库， 打开对应的开关即可激活。如图: <img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/ci/travis_active.png" alt="travis_active"></p><h3 id="travis-yml"><a href="#travis-yml" class="headerlink" title=".travis.yml"></a><code>.travis.yml</code></h3><p>在项目根目录下添加 <code>.travis.yml</code>, <code>travis</code> 提供了多种语言要用的例子， 可以参考<a href="https://docs.travis-ci.com/user/language-specific/" target="_blank" rel="noopener">这儿</a>。这儿想实现一个 <code>flutter</code> 打包 <code>apk</code> 的 <code>CI</code> , 我们可以参照它提供的 <code>android</code> 例子。 但是 <code>flutter</code> 和 <code>android</code> 都更新的太快了，所以例子上用的都是老的 <code>android</code> 。</p><p>这是我的 <code>.travis.yml</code> ， 基于最新的 <code>flutter</code> 版本（目前稳定版是 <code>flutter 1.5.4</code> ）与 <code>android28</code> 进行打包。我这儿暂时没有加签名…<br><a id="more"></a></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">os:</span> <span class="string">linux</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">android</span></span><br><span class="line"><span class="comment"># android 相关的证书</span></span><br><span class="line"><span class="attr">licenses:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">android-sdk-preview-license-.+</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">android-sdk-license-.+</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">google-gdk-license-.+</span></span><br><span class="line"><span class="comment"># android 相关环境</span></span><br><span class="line"><span class="attr">android:</span></span><br><span class="line"><span class="attr">  components:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">tools</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">platform-tools</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">build-tools-28.0.3</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">android-28</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">sys-img-armeabi-v7a-google_apis-28</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">extra-android-m2repository</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">extra-google-m2repository</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">extra-google-android-support</span></span><br><span class="line"><span class="attr">jdk:</span> <span class="string">oraclejdk8</span></span><br><span class="line"><span class="attr">sudo:</span> <span class="literal">false</span></span><br><span class="line"><span class="comment"># 运行 ci 的 docker 容器</span></span><br><span class="line"><span class="attr">addons:</span></span><br><span class="line"><span class="attr">  apt:</span></span><br><span class="line"><span class="attr">    sources:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">ubuntu-toolchain-r-test</span></span><br><span class="line"><span class="attr">    packages:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">libstdc++6</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">fonts-droid</span></span><br><span class="line"><span class="comment"># flutter doctor --android-licenses 要求先运行下面这条语句， yes | 表示后面的命令如果需要你输入 y/n 会自动帮你输入 y</span></span><br><span class="line"><span class="attr">before_install:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="literal">yes</span> <span class="string">| sdkmanager --update</span></span><br><span class="line"><span class="string"></span><span class="attr">before_script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">git</span> <span class="string">clone</span> <span class="attr">https://github.com/flutter/flutter.git</span> <span class="bullet">-b</span> <span class="string">stable</span> <span class="bullet">--depth</span> <span class="number">1</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">export</span> <span class="string">PATH="$PATH:`pwd`/flutter/bin"</span></span><br><span class="line"><span class="attr">script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">flutter</span> <span class="string">packages</span> <span class="string">get</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">flutter</span> <span class="string">precache</span></span><br><span class="line">  <span class="comment"># 由于用的新的 android , 需要接受额外的一些证书</span></span><br><span class="line"><span class="bullet">  -</span> <span class="literal">yes</span> <span class="string">| flutter doctor --android-licenses</span></span><br><span class="line"><span class="string">  - flutter doctor &amp;&amp; flutter -v build apk</span></span><br><span class="line"><span class="string"># 缓存</span></span><br><span class="line"><span class="string"></span><span class="attr">cache:</span></span><br><span class="line"><span class="attr">  directories:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">"$HOME/.pub-cache"</span></span><br></pre></td></tr></table></figure><p>每次提交代码后就会自动触发 <code>CI</code>, 可以在 <code>travis-ci.org</code> 下你的仓库中看到。比如我的这个 <a href="https://travis-ci.org/jintangWang/my_app" target="_blank" rel="noopener">demo</a> ,可以看到</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>如果需要自动打包到 <code>github</code> ，我们还需要在 <code>.travis.yml</code> 中添加部署的代码。</p><h4 id="本地安装-travis"><a href="#本地安装-travis" class="headerlink" title="本地安装 travis"></a>本地安装 travis</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install travis</span><br></pre></td></tr></table></figure><h4 id="生成部署命令"><a href="#生成部署命令" class="headerlink" title="生成部署命令"></a>生成部署命令</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">travis setup releases</span><br></pre></td></tr></table></figure><p>会要求你输入你的 <code>github</code> 账号， <code>github</code> 密码，<code>apk</code> 相对于项目根目录的路径，后面的直接选择回车表示 yes 就行了。 结果如图： <img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/ci/travis_release.png" alt="travis_release"></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  provider:</span> <span class="string">releases</span></span><br><span class="line"><span class="attr">  api_key:</span></span><br><span class="line"><span class="attr">    secure:</span> <span class="string">lASdvkCQ58SnGHwtaDk9s6ibWdQrnfxrnkNv3igt4fkLGMZknsDf821w1X+U+tcI7pP/vgJ4f4ijQAzmpAmt5WX6j2YBvMKWA8Wz7xQvs4iPL45uA3bD4FZcssQM9HHuKgBQnUyQ5nIcyEj8RRDFXiBGGVLmus2bEjocHThyH4B9BreWAaW0wudOwUoTmRmHCLNmoD1lgiraDT47piJFXGdlPNy3bUfHpKy9uetXVkDTVzYGm2mqYn/PAfhgnd67/xKUwXuCbBFTIdOYQ3VMfIl9vzZ3B1bMgYJNv2Qg9/9ueW6AwQbjVbakSw+cXIW+PjOD9TERE2PDxQ+5z6bWkHEdr5CzJ7RudMJ1pBdZFiA346XKhUZnMJdkMQy7NLu3g3yk655/iPAzWPOaqh0mps3KPxpWfFQd2UtPPig94Fg+EgzwttxdHZVRWIeXG/JLTFBfJl+ZLcwM90UAxk0iGgSnFmonvB/x6kGYFj0aNzsZR+BRvl7SkxW+gZfwu3c27l/Ib7fl6WiiVaZrTPJq1As5xc4eIbXJhHxLHouXiqQl096NK4Nm5NvISFhOL6MCxK8bDGoQhAKg+ewMOgBYDlPBqZ7jV3+wzx9iuIBXqSeN1WumUrGEkc3y7BIaoFSv2btnNgkWiSjWufoICkgf1aPRSSbK+nmO94uaYQ9265A=</span></span><br><span class="line"><span class="attr">  file:</span> <span class="string">build/app/outputs/apk/release/app-release.apk</span></span><br><span class="line"><span class="attr">  on:</span></span><br><span class="line"><span class="attr">    repo:</span> <span class="string">jintangWang/my_app</span></span><br><span class="line">    <span class="comment"># 上面的是生成的，我们再添加上下面的配置</span></span><br><span class="line">    <span class="comment"># 只有给 commit 打上 tag 才会触发 部署</span></span><br><span class="line"><span class="attr">    tags:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 防止上传的 apk 被删除</span></span><br><span class="line"><span class="attr">  skip_cleanup:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p><strong>最后</strong>: 提交一个打了 <code>tag</code> 的 <code>commit</code> （不然不会触发部署），<code>build</code> 成功之后会自动部署到 <code>github</code> 仓库的 <a href="https://github.com/jintangWang/my_app/releases" target="_blank" rel="noopener">release</a> 下。完整的例子就在我的这个<a href="https://github.com/jintangWang/my_app" target="_blank" rel="noopener">仓库</a></p><h2 id="Gitlab-CI"><a href="#Gitlab-CI" class="headerlink" title="Gitlab CI"></a>Gitlab CI</h2><h3 id="Gitlab-Runner"><a href="#Gitlab-Runner" class="headerlink" title="Gitlab Runner"></a>Gitlab Runner</h3><p><code>Gitlab Runner</code> 用于跑我们的 <code>CI</code> 脚本并将结果返回给 <code>Gitlab</code> 。</p><p>这里我们选择使用 <code>docker</code> 作为我们的 <code>runner</code> 。你也可以选择其他 <code>runner</code> , 比如： <code>macOS</code> 本地、 <code>windows</code> 本地、 <code>linux</code> 本地 … 具体可以看 <a href="https://docs.gitlab.com/runner/" target="_blank" rel="noopener">这儿</a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>我是 <code>macOS</code> 系统，用下面的步骤安装 <code>runner</code> 。其他系统可以查看 <a href="https://docs.gitlab.com/runner/install/docker.html" target="_blank" rel="noopener">官方文档</a></p><ul><li>首先要确保你本地有 <code>docker</code> 并启动。这儿不再赘述，我已经安装了。</li><li><p>运行 <code>gitlab-runner</code> 镜像生成容器，本地找不到此镜像会从网上下载。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name gitlab-runner --restart always \</span><br><span class="line">-v /Users/Shared/gitlab-runner/config:/etc/gitlab-runner \</span><br><span class="line">-v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">gitlab/gitlab-runner:latest</span><br></pre></td></tr></table></figure><p>大概解释一下：</p><ul><li><code>--name</code> 表示为这个容器指定名称，后面的 <code>gitlab-runner</code> 是我们设定的容器名称。</li><li><code>-v</code> 表示挂载卷。</li><li><p>最后面的 <code>gitlab/gitlab-runner:latest</code> 是下载的镜像名。</p><p>更多 <a href="https://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">docker 命令</a> 请自行查阅。完成后可以通过 <code>docker ps</code> 看到正在运行的 <code>docker</code> 容器，里面有一个名称为 <code>gitlab-runner</code> 。</p></li></ul></li></ul><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><p>其他系统注册查看 <a href="https://docs.gitlab.com/runner/register/index.html#docker" target="_blank" rel="noopener">这儿</a></p><blockquote><p>注册用的 <code>url</code> 和 <code>token</code> 在 仓库—— <code>Settings</code> —— <code>CI/CD</code>下的 <code>Runners</code> —— <code>Specific Runners</code> 下可以看到，如图： <img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/ci/runner-regist.png" alt="runner-regist"></p></blockquote><ul><li><p>注册命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -t -i -v /Users/Shared/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register</span><br></pre></td></tr></table></figure></li><li><p>输入 <code>gitlab</code> 实例的 <code>url</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com )</span><br><span class="line">http://gitlab.ziggurat.cn/</span><br></pre></td></tr></table></figure></li><li><p>输入 <code>token</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">lease enter the gitlab-ci token <span class="keyword">for</span> this runner</span><br><span class="line">xxx(上面图片中得到的 token )</span><br></pre></td></tr></table></figure></li><li><p>填写描述</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please enter the gitlab-ci description <span class="keyword">for</span> this runner</span><br><span class="line">flutter build apk</span><br></pre></td></tr></table></figure></li><li><p>填写 tag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please enter the gitlab-ci tags <span class="keyword">for</span> this runner (comma separated):</span><br><span class="line">flutter, apk</span><br></pre></td></tr></table></figure></li><li><p>填写执行器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please enter the executor: docker-ssh+machine, kubernetes, docker-ssh, virtualbox, docker+machine, ssh, docker, parallels, shell:</span><br><span class="line">docker</span><br></pre></td></tr></table></figure></li><li><p>填写执行 <code>CI</code> 使用的 <code>docker</code> 镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Please enter the Docker image (eg. ruby:2.1):</span><br><span class="line">alpine:latest</span><br></pre></td></tr></table></figure><p><code>alpine:latest</code> 是一个非常小的 <code>docker</code> 镜像，<code>linux</code> 系统。由于我们一般会在 <code>.gitlab-ci.yml</code> 中声明 <code>docker</code> 镜像，而且那个优先级比这儿的高。所以一般填写 <code>alpine:latest</code> 就行了</p></li></ul><p>这些步骤完成后就可以在上面图片的下面看到你注册成功的 <code>runner</code>， 如图： <img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/ci/registed_runner.png" alt="registed_runner"></p><p>这个命令会在注册完成后运行起来这个 <code>docker</code> 镜像，你可以通过 <code>docker ps</code> 看到。所以图上那个 <code>Runner</code> 是 <code>active</code> 状态。</p><blockquote><ul><li>我这儿只能使用 <code>Specific Runners</code> 。 我使用的 <code>gitlab</code> 实例是公司注册的，管理员可以通过设置为某个仓库打开 <code>Shared Runners</code>。个人在 <code>gitlab.com</code> 里开源项目可以直接使用 <code>Shared Runners</code></li><li><code>Gitlab Runner</code> 只需要安装一次，对于不同项目的 <code>CI</code> ，可以使用同一个 <code>docker</code> 镜像，只需要第一次注册一下，后面直接运行就可以了。</li></ul></blockquote><h3 id="gitlab-ci-yml"><a href="#gitlab-ci-yml" class="headerlink" title=".gitlab-ci.yml"></a><code>.gitlab-ci.yml</code></h3><p>在注册完 <code>runner</code> 后，我们需要在项目的根目录下创建一个文件 <code>.gitlab-ci.yml</code> 。 在里面编写将要在 <code>runner</code> 里面执行的命令，完成之后每次提交都会触发我们的 <code>CI</code> 脚本，在仓库的 <code>Pipelines</code> 下就可以看到我们正在跑的 <code>CI</code>。</p><p>这儿我们使用 <code>fastlane</code> 给 <code>flutter</code> 项目进行打包。 <a href="https://docs.fastlane.tools/" target="_blank" rel="noopener">fastlane</a> 是一个自动构建 <code>Android</code> 和 <code>iOS</code> app 的工具。由于本地打包 <code>iOS</code> 特别麻烦， 而 <code>fastlane</code> 针对两个平台有基本统一的简单操作，<code>flutter</code> 官方也推荐 <a href="https://flutter.dev/docs/deployment/fastlane-cd" target="_blank" rel="noopener">fastlane 部署</a>。So ， 你懂得…</p><p>我的 <code>.gitlab-ci.yml</code> 中对于 <code>apk</code> 的打包只有简单的两句， 因为关于 <code>fastlane</code> 的配置文件与脚本我都已经在本地生成并上传了 <a href="https://gitlab.com/jintangWang/test_fastlane" target="_blank" rel="noopener">demo仓库</a> 里面，这儿只实现 <code>Andriod</code> 的无签名打包，感兴趣的可以看 <a href="https://gitlab.com/jintangWang/test_fastlane/tree/master/android/fastlane" target="_blank" rel="noopener">fastlane 相关文件</a>。</p><p><code>.gitlab-ci.yml</code> : <a href="https://docs.gitlab.com/ee/ci/yaml/#when" target="_blank" rel="noopener">官方语法说明</a><br></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用此镜像运行打包</span></span><br><span class="line"><span class="attr">image:</span> <span class="string">cirrusci/flutter</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">build</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">export</span> <span class="string">FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build-apk:</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">cd</span> <span class="string">android</span></span><br><span class="line">  <span class="comment"># 该镜像已经包含了fastlane</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">fastlane</span> <span class="string">android</span> <span class="string">release</span></span><br><span class="line">  <span class="comment"># 要上传的包</span></span><br><span class="line"><span class="attr">  artifacts:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">"app-release-$CI_COMMIT_SHORT_SHA.apk"</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">build/app/outputs/apk/release/app-release.apk</span></span><br><span class="line"><span class="attr">    expire_in:</span> <span class="number">1</span> <span class="string">week</span> <span class="comment"># 过期时间</span></span><br></pre></td></tr></table></figure><p></p><h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><p>只要你有新的 <code>push</code> ， 在 <code>gitlab</code> 上就会触发 <code>pipeline</code> ， 如果正常通过，就应该是这样的： <img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/ci/gitlab_result.png" alt="gitlab_result"><br>由于 <code>.gitlab-ci.yml</code> 有部署命令，所以还可以下载打包好的 <code>apk</code>。 点击右侧的云朵图标就可以看到我们上传的 <code>artifact</code> 了，点击就可以下载了</p><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ol><li>新的提交之后没有触发 <code>pipeline</code><br>如图，<img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/ci/runner_set_btn.png" alt="runner_set_btn"><br>打开 <code>runner</code> 的设置页面， 检查一下是否设置了 <strong>Run untagged jobs</strong> ，我的是这样的：<br><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/ci/runner_set.png" alt="runner_set"></li><li><p>The Job is stuck because you don’t have any active runners<br>检查下本地运行的 <code>docker</code> 容器，正常是有两个，如图： <img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/ci/runner_docker.png" alt="runner_docker"><br>如果有多余的，删除掉并重启 <code>gitlab-runner</code> （这是我们前面注册 <code>runner</code> 时的容器名称）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart gitlab-runner</span><br></pre></td></tr></table></figure></li><li><p>ERROR: Uploading artifacts to coordinator… error<br>在最后上传包的时候总是报这个错。在经过多次实验以后发现是我司注册的 <code>gitlab</code> 实例的问题，需要管理员设置允许的 <code>artifact</code> 大小，可以参考 <a href="https://docs.gitlab.com/ee/user/admin_area/settings/continuous_integration.html" target="_blank" rel="noopener">这儿</a>，我司应该有限制这个。 而我之前创建的仓库就在我司的 <code>gitlab</code> 实例上，所以导致我的 <code>artifact</code> 一直上传失败… 真是醉了…</p><p>最后将 <code>demo</code> 转到了 <a href="https://gitlab.com" target="_blank" rel="noopener">https://gitlab.com</a> , 重新提交，打包和部署都成功。自己也没重新注册 <code>runner</code> ，直接使用了 <code>Shared Runners</code> 。当然这个有点限制，对开源项目限制了 2000分钟/月。</p></li></ol><p><strong>总结：</strong> <code>CI</code> 是个好东西，可以做好多方便的东西，可以自动化部署博客啊等等。更多精彩，值得探索…</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;&lt;code&gt;CI&lt;/code&gt; (continuous integration) : 持续集成。用来做一些自动化工作，比如程序的打包，单元测试，部署等。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;我最常用的 &lt;code&gt;git&lt;/code&gt; 仓库是 &lt;code&gt;Github&lt;/code&gt; , &lt;code&gt;Travis CI&lt;/code&gt; 对 &lt;code&gt;Github&lt;/code&gt; 支持的特别好，使用非常方便。&lt;/li&gt;&lt;li&gt;公司的仓库在 &lt;code&gt;Gitlab&lt;/code&gt; 上， &lt;code&gt;Gitlab&lt;/code&gt;自己内部集成了 &lt;code&gt;Gitlab CI&lt;/code&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;本文主要介绍这两种 &lt;code&gt;CI&lt;/code&gt; 自动化打包部署 &lt;code&gt;flutter apk&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;Travis-CI&quot;&gt;&lt;a href=&quot;#Travis-CI&quot; class=&quot;headerlink&quot; title=&quot;Travis CI&quot;&gt;&lt;/a&gt;Travis CI&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Travis CI&lt;/code&gt; 与 &lt;code&gt;Github&lt;/code&gt; 结合比较紧密，对 &lt;code&gt;GitHub&lt;/code&gt; 上的开源Repo是免费的，私有Repo收费。&lt;/p&gt;&lt;p&gt;&lt;code&gt;Travis CI&lt;/code&gt; 有两个网址，一个是 &lt;a href=&quot;https://travis-ci.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;travis-ci.org&lt;/a&gt; ， 另一个是 &lt;a href=&quot;https://travis-ci.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;travis-ci.com&lt;/a&gt; 。 官方推荐使用 &lt;code&gt;travis-ci.com&lt;/code&gt; ， 告诉我们 &lt;code&gt;travis-ci.org&lt;/code&gt; 后面会全部迁徙到 &lt;code&gt;travis-ci.com&lt;/code&gt; 。 目前在两个网址都可以实现效果，没啥区别，但不能同时使用。&lt;/p&gt;&lt;p&gt;下面以 &lt;code&gt;travis-ci.org&lt;/code&gt; 为例，反正我刚开始用的时候就选了这个，索性 “将错就错”&lt;/p&gt;&lt;h3 id=&quot;激活要运行-CI-的仓库&quot;&gt;&lt;a href=&quot;#激活要运行-CI-的仓库&quot; class=&quot;headerlink&quot; title=&quot;激活要运行 CI 的仓库&quot;&gt;&lt;/a&gt;激活要运行 CI 的仓库&lt;/h3&gt;&lt;p&gt;使用 &lt;code&gt;github&lt;/code&gt; 账号登录 &lt;code&gt;travis-ci.org&lt;/code&gt; ， 在个人设置中心可以看到自己在 &lt;code&gt;github&lt;/code&gt; 上的仓库， 打开对应的开关即可激活。如图: &lt;img src=&quot;https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/ci/travis_active.png&quot; alt=&quot;travis_active&quot;&gt;&lt;/p&gt;&lt;h3 id=&quot;travis-yml&quot;&gt;&lt;a href=&quot;#travis-yml&quot; class=&quot;headerlink&quot; title=&quot;.travis.yml&quot;&gt;&lt;/a&gt;&lt;code&gt;.travis.yml&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;在项目根目录下添加 &lt;code&gt;.travis.yml&lt;/code&gt;, &lt;code&gt;travis&lt;/code&gt; 提供了多种语言要用的例子， 可以参考&lt;a href=&quot;https://docs.travis-ci.com/user/language-specific/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这儿&lt;/a&gt;。这儿想实现一个 &lt;code&gt;flutter&lt;/code&gt; 打包 &lt;code&gt;apk&lt;/code&gt; 的 &lt;code&gt;CI&lt;/code&gt; , 我们可以参照它提供的 &lt;code&gt;android&lt;/code&gt; 例子。 但是 &lt;code&gt;flutter&lt;/code&gt; 和 &lt;code&gt;android&lt;/code&gt; 都更新的太快了，所以例子上用的都是老的 &lt;code&gt;android&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;这是我的 &lt;code&gt;.travis.yml&lt;/code&gt; ， 基于最新的 &lt;code&gt;flutter&lt;/code&gt; 版本（目前稳定版是 &lt;code&gt;flutter 1.5.4&lt;/code&gt; ）与 &lt;code&gt;android28&lt;/code&gt; 进行打包。我这儿暂时没有加签名…&lt;br&gt;
    
    </summary>
    
      <category term="flutter" scheme="https://jintang.github.io/categories/flutter/"/>
    
    
      <category term="flutter" scheme="https://jintang.github.io/tags/flutter/"/>
    
      <category term="CI" scheme="https://jintang.github.io/tags/CI/"/>
    
  </entry>
  
  <entry>
    <title>dart需知</title>
    <link href="https://jintang.github.io/2019/04/24/dart%E9%9C%80%E7%9F%A5/"/>
    <id>https://jintang.github.io/2019/04/24/dart需知/</id>
    <published>2019-04-24T08:12:30.000Z</published>
    <updated>2019-07-10T07:48:51.980Z</updated>
    
    <content type="html"><![CDATA[<p>谷歌开发了 <code>dart</code> 语言，目前已经可以用作 <code>web</code> 端 和 移动端(<code>flutter</code>)，在谷歌的展望中以后还可以做桌面端，大一统啊。 此处记录下一些基本又重要，自己会选择性忽视和经常要用的点。</p><p>特点：</p><ul><li>基于类，面向对象，类可以继承，但只可以单继承</li><li>接口实现（多态），抽象类，泛型</li><li>单线程（拥有异步处理）</li><li>动态类型(类似 <code>js</code> ，拥有 <code>var</code>) 或 类型注解(使用 静态类型关键字 来声明变量，以获得严格的类型检查)。我们可以这样编写我们的代码，在函数的入口，即定义函数的参数时使用 类型注解；而在函数内部，当类型并不重要时使用 动态类型。</li></ul><a id="more"></a><h3 id="基本类型相关"><a href="#基本类型相关" class="headerlink" title="基本类型相关"></a>基本类型相关</h3><ol><li><code>double</code> 是 64 位</li><li><code>String</code> 是 UTF16</li></ol><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">StringBuffer</span> sb = <span class="keyword">new</span> <span class="built_in">StringBuffer</span>();</span><br><span class="line">  sb.write(<span class="string">"Hello"</span>);</span><br><span class="line">  sb.writeAll([<span class="string">'space'</span>, <span class="string">'and'</span>, <span class="string">'more'</span>]);</span><br><span class="line"> </span><br><span class="line">  <span class="built_in">print</span>(sb);</span><br><span class="line">  <span class="built_in">print</span>(sb.toString());</span><br><span class="line">  </span><br><span class="line">  sb.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>常用方法使用 <code>js</code> 作为比较。</p><ol><li><p><code>foreach</code> 类似 <code>js</code> 的 <code>foreach</code><br>如果想遍历时获取 <code>index</code> , 转为 <code>{&#39;index&#39;: item}</code> 的对象遍历， 完成之后再转为 list :</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list.asMap().forEach((index, item) &#123;</span><br><span class="line">    <span class="comment">// do something...</span></span><br><span class="line">&#125;).toList()</span><br></pre></td></tr></table></figure></li><li><p><code>map</code> 类似 <code>js</code> 的 <code>map</code></p></li><li><code>where</code> 类似 <code>js</code> 的 <code>filter</code>： 删选符合要求的元素</li><li><code>any</code> 类似 <code>js</code> 的 <code>every</code>： 检测列表中是否所有元素都满足要求</li></ol><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>两个特点：没有顺序，唯一元素<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set</span> english  = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">english.add(<span class="string">'door'</span>);</span><br><span class="line">english.add(<span class="string">'car'</span>);</span><br><span class="line">english.add(<span class="string">'door'</span>);</span><br><span class="line">english.add(<span class="string">'lunar'</span>);</span><br><span class="line">english.add(<span class="string">'era'</span>);</span><br><span class="line"><span class="built_in">print</span>(english); <span class="comment">// &#123;door, car, lunar, era&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span> spanish = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">spanish.addAll([<span class="string">'era'</span>, <span class="string">'lunar'</span>, <span class="string">'hola'</span>]);</span><br><span class="line"><span class="built_in">print</span>(spanish); <span class="comment">//  &#123;era, lunar, hola&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(english.intersection(spanish)); <span class="comment">//  &#123;lunar, era&#125;</span></span><br><span class="line"><span class="built_in">print</span>(english.difference(spanish));   <span class="comment">//  &#123;door, car&#125;</span></span><br><span class="line"><span class="built_in">print</span>(english.union(spanish)); <span class="comment">// &#123;door, car, lunar, era, hola&#125;</span></span><br></pre></td></tr></table></figure><p></p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span> joe = &#123;</span><br><span class="line">    <span class="string">"name"</span>  : <span class="string">"Joe"</span>,</span><br><span class="line">    <span class="string">"email"</span> : <span class="string">"joe@somewhere.com"</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">print</span>(joe); <span class="comment">// &#123;name: Joe, email: joe@somewhere.com&#125; </span></span><br><span class="line"></span><br><span class="line">joe.putIfAbsent(<span class="string">'email'</span>, () =&gt; <span class="string">'a@b.com'</span>);</span><br><span class="line"><span class="built_in">print</span>(joe); <span class="comment">// &#123;name: Joe, email: joe@somewhere.com&#125;</span></span><br><span class="line">joe.putIfAbsent(<span class="string">'birthdate'</span>, () =&gt; <span class="keyword">new</span> <span class="built_in">DateTime</span>.now());</span><br><span class="line"><span class="built_in">print</span>(joe);</span><br><span class="line"><span class="comment">// &#123;name: Joe, email: joe@somewhere.com, birthdate: 2014-02-25 20:53:04.548&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(joe.containsKey(<span class="string">'email'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout"></a>setTimeout</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:async'</span>;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">new</span> Timer(<span class="keyword">new</span> <span class="built_in">Duration</span>(seconds: <span class="number">1</span>), () =&gt; <span class="built_in">print</span>(<span class="string">"timeout"</span>));</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"end main"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="iterator-与-Iterable"><a href="#iterator-与-Iterable" class="headerlink" title="iterator 与 Iterable"></a>iterator 与 Iterable</h3><p><code>iterator</code>：<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = [<span class="string">'Foo'</span>, <span class="string">'Bar'</span>, <span class="string">'Qux'</span>];</span><br><span class="line"><span class="keyword">var</span> it = names.iterator;</span><br><span class="line">  <span class="keyword">while</span> (it.moveNext()) &#123;</span><br><span class="line">    <span class="keyword">var</span> n = it.current;</span><br><span class="line">    <span class="built_in">print</span>(n); <span class="comment">// Foo Bar Qux</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p></p><p><code>Iterable</code>:<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> numbers = <span class="keyword">new</span> <span class="built_in">Iterable</span>.generate(<span class="number">5</span>, (i) =&gt; i);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> n <span class="keyword">in</span> numbers) &#123;</span><br><span class="line">   <span class="built_in">print</span>(n); <span class="comment">// 0 1 2 3 4</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;谷歌开发了 &lt;code&gt;dart&lt;/code&gt; 语言，目前已经可以用作 &lt;code&gt;web&lt;/code&gt; 端 和 移动端(&lt;code&gt;flutter&lt;/code&gt;)，在谷歌的展望中以后还可以做桌面端，大一统啊。 此处记录下一些基本又重要，自己会选择性忽视和经常要用的点。&lt;/p&gt;&lt;p&gt;特点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;基于类，面向对象，类可以继承，但只可以单继承&lt;/li&gt;&lt;li&gt;接口实现（多态），抽象类，泛型&lt;/li&gt;&lt;li&gt;单线程（拥有异步处理）&lt;/li&gt;&lt;li&gt;动态类型(类似 &lt;code&gt;js&lt;/code&gt; ，拥有 &lt;code&gt;var&lt;/code&gt;) 或 类型注解(使用 静态类型关键字 来声明变量，以获得严格的类型检查)。我们可以这样编写我们的代码，在函数的入口，即定义函数的参数时使用 类型注解；而在函数内部，当类型并不重要时使用 动态类型。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="flutter" scheme="https://jintang.github.io/categories/flutter/"/>
    
    
      <category term="dart" scheme="https://jintang.github.io/tags/dart/"/>
    
  </entry>
  
  <entry>
    <title>计算机知识</title>
    <link href="https://jintang.github.io/2019/04/10/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"/>
    <id>https://jintang.github.io/2019/04/10/计算机知识/</id>
    <published>2019-04-10T14:35:44.000Z</published>
    <updated>2019-11-18T08:15:20.091Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>看 <a href>Crash Course</a> 得到的一部分知识。讲的真好，翻译的也真好。</p></blockquote><h3 id="集成电路IC"><a href="#集成电路IC" class="headerlink" title="集成电路IC"></a>集成电路IC</h3><p>每两年左右，随着材料和制造技术的发展，同样大小的空间，IC能塞进两倍数量的晶体管。这就是 <strong>摩尔定律</strong></p><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li>操作系统可以运行多个程序，但是当我们切换程序的时候我们不希望丢失数据，所以每个程序有指定的内存区。</li><li>但有的程序在使用过程中需要更多地内存，所以就会向操作系统提出申请分配更多地内存。如果同意，就会分配另外的内存，但是由于程序都有指定的内存区，所以新分配内存和之前指定的内存就不是连续的。为了解决这个问题，出现了<strong>虚拟内存</strong>， 虚拟内存和真实内存是映射关系，虽然程序的实际内存是不连续的，但是虚拟内存是连续的，从 0 到 xxxx</li><li>由于程序有不同的内存，所以可以<strong>内存保护</strong>。不同的程序无法访问其他程序的内存。早期的 <code>windows</code> 由于缺乏内存保护，有时候程序的不当使用会导致系统崩溃，从而引发蓝屏</li></ul><h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p>文件的本质是一段二进制，通常在前面的几位是文件头，描述了文件的大小，描述了如图片文件的行列数（什么时候换行）…</p><ul><li>为了方便扩展文件大小，硬盘上分为一个个存储块，每个文件占用一个或多个存储块，文件占用的存储块随着文件顺序排列，当文件变大的时候分配新的未使用的存储快</li><li>为了记录文件所对应存储快，文件同层下会有一个目录文件，记录了当前目录下所有文件的相关信息：创建时间、修改时间、是否是目录、所在的存储块…<ul><li><code>windows</code> 删除文件的时候其实只是删除了目录文件下对该文件的记录，让我们无法看到，而没有在在硬盘上的删除该文件。所以我们可以通过有些工具恢复删除的文件</li><li><code>windows</code> 上同一块存储上移动文件特别快，原因是因为只需要在原来目录下的目录文件中删除该文件信息，然后再目标目录下的目录文件中添加该文件信息即可。而不是在存储结构上真实的移动</li><li><code>windows</code> 在多次进行文件的删除、修改、迁移之后，会使得很多文件在存储上占用的存储块都是不连续的。而 <strong>碎片整理</strong> 就是从新让文件在存储上顺序排列的过程（ <code>SSD</code> 不需要 <strong>碎片整理</strong> ）</li></ul></li></ul><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><p>图片颜色用 红绿蓝 三种颜色合成表示，每个颜色都是 1 个字节， 所以一个 16px 的图片 占用的内存是 16 * 3 = 48 字节。我们可以用以下方法实现减少内存。<br><a id="more"></a></p><h4 id="无损压缩"><a href="#无损压缩" class="headerlink" title="无损压缩"></a>无损压缩</h4><ul><li>游程编码（Run-Length Encoding），常用于出现很多重复值的文件。比如一个图片颜色是 “黄黄黄绿绿绿…” 这种格式，可以改为 “3黄3绿…” 这种格式的代码，保持格式一致。就减少了很少内存。这是 <strong>无损压缩</strong></li><li>用一种更紧凑的方式表示数据。我们需要一个字典，存储 “代码” 和 “数据” 的关系。这次图片不按像素分，而是按照块分，将每种块换算成不同的代码。根据块出现在文件中的频率，用 “霍夫曼树” 进行排练。这也是一种 <strong>无损压缩</strong>。<ul><li>定义 :<ul><li>首先，列出所有块和出现频率，每轮选取两个最低频率的块，组成一个树</li><li>然后，将上一步的树和其他的块排列，选取两个频率最低的块，组成树</li><li>…</li><li>最后的整个树就叫做 “霍夫曼树”</li></ul></li><li>实例 ：<ul><li>一个文件分为： YY(黄黄)、WY（白黄）、BY（黑黄）、BB（黑黑）</li><li>按 “霍夫曼树” 排列为 <img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/crash%20course/huofuman_tree.jpg" alt="houfuman_tree"></li></ul></li><li>将每个块翻译为代码，且由于在树中的位置不同，这些代码是不会重复的，结果最后为：<img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/crash%20course/houfuman_code.png" alt="houfuman_code">。48 字节的图片转换为了 14 位 的 10110000111100 , 在前面加上字典，就完成了整个压缩，结果是 30 字节。</li></ul></li></ul><p>几乎所有的无损压缩格式都由上面两个方法组合起来使用，比如： <code>GIF , PNG , PDF , ZIP</code></p><h4 id="有损压缩"><a href="#有损压缩" class="headerlink" title="有损压缩"></a>有损压缩</h4><p>丢掉人类无法识别的数据，这种删除人类无法感知的数据的方法叫做 “感知编码” ，比如：</p><ul><li>声音有损压缩，去除超声波，以主要精度表示人声，次要精度表示低声波。如 skype 打电话，网速慢的时候压缩会去除更多数据，所以 skype 打电话像机器人。没有压缩的音频格式有 <code>WAV 、 FLAC</code> ， 压缩的有 <code>MP3</code> 等，占用内存小了 10 倍</li><li>图片有损压缩， 如 <code>JPEG</code> ， 删除人类无法感知的。</li><li>视频压缩：视频本质是一长串图片，但是视频每一帧之间的差别是很小的。很多视频格式<strong>只存帧之间变化的部分</strong>。<code>NPEG-4</code> 是常见标准，可以比原图片小 20 - 200 倍。</li></ul><h3 id="屏幕显示"><a href="#屏幕显示" class="headerlink" title="屏幕显示"></a>屏幕显示</h3><ul><li>阴极射线管 （<code>CRT</code>）:把电子发射到 有磷光体涂层的屏幕了，当电子撞击涂层时，会发光几分之一秒。电子可以用磁场控制。所以可以用两种方法绘制<ul><li>引到电子束描绘出形状，叫做 “尺量扫描”</li><li>按固定路径，一行行扫描，从上到下，从左往右，不断重复。只在特定的点打开电子束，叫做 “光栅扫描”</li></ul></li><li>位图显示，内存中的位对应屏幕上的像素。</li></ul><h3 id="3D-图形"><a href="#3D-图形" class="headerlink" title="3D 图形"></a>3D 图形</h3><h4 id="线框渲染"><a href="#线框渲染" class="headerlink" title="线框渲染"></a>线框渲染</h4><p>把 3D 坐标拍平到 2D屏幕上，叫 <strong>线框渲染</strong>， 常用方法有：</p><ul><li>正交投影： 立方体的各个边，在投影中互相平行</li><li>透视投射： 在真实的 3D 世界中，平行线段会在远处收敛于一点。如图：<img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/crash%20course/toushi_toushe.png" alt="透视投射"></li></ul><h4 id="填充图形"><a href="#填充图形" class="headerlink" title="填充图形"></a>填充图形</h4><p><strong>3D</strong> 图形除了线框渲染，还需要填充</p><p>简单的 <strong>3D</strong> 图形可以用矩形用作最小组成单元。对于复杂的 <strong>3D</strong> 投射，一般使用三角形用作最小组成单元。因为 3 个点可以确定唯一的一个面。</p><p>下面是几种填充算法：</p><ul><li>扫描线算法<ol><li>先读三角形的3个点， 找最大和最小的 Y 值，只在这两点间工作。如图 <img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/crash%20course/scan_origin.png" alt="初始图形"></li><li>然后从上往下，每次一行，计算每一行与三角形相交的2个点。因为是三角形，如果相交一条边，必然相交另一条边</li><li>一直到扫到底部完成，结果如图 <img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/crash%20course/scan_finish.png" alt="扫描线结果"></li></ol></li></ul><p><strong>算法缺点：</strong></p><ul><li>扫描线算法：<ul><li>边缘锯齿</li></ul></li></ul><p><strong>缺点解决方案：</strong></p><ul><li>减轻锯齿：<ul><li>抗锯齿： 字体和图标常用。通过判断三角形切过像素的程度，来调整颜色，具体做法如下：<ul><li>如果像素在三角形内部，就直接涂颜色</li><li>如果三角形划过像素，颜色就浅一些，达到一种边缘羽化的效果，结果如图： <img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/crash%20course/scan_yuhua.png" alt="scan_yuhua"></li></ul></li></ul></li></ul><h4 id="实际渲染过程"><a href="#实际渲染过程" class="headerlink" title="实际渲染过程"></a>实际渲染过程</h4><p>由于图形重叠形成遮挡，所以渲染过程有这么几种：</p><ul><li><strong>画家算法渲染：</strong> 用排序算法将远处的先渲染，然后根据距离再渲染近的。因为画家也是先画背景，再画近的，所以叫 <strong>画家算法</strong> 。</li><li><strong>深度缓冲(Z-buffering)渲染：</strong>不用排序，所以比前面的算法快。具体步骤：<ul><li>算法会记录每个像素距离屏幕的位置，在内存中存有一个数字矩阵，每个元素总是记录距离屏幕的最小值。</li><li>矩阵中每个元素的初始值是无限大，然后类似于扫描线算法进行扫描三角形，总是记录更低的值。假如A三角形距离屏幕为20，由于 20 &lt; “无限大” ，所以记录为20。依次记录完所有的三角形，由于记录的总是最小值，所以跟渲染三角形的顺序没有关系。 如图： <img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/crash%20course/z_buffering.png" alt="z-buffering"></li></ul></li></ul><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="基础概念与过程"><a href="#基础概念与过程" class="headerlink" title="基础概念与过程"></a>基础概念与过程</h4><ul><li>指数退避：一个局域网中的不同计算机使用同一载体传输数据时，相互堵塞，各个计算机会等待随机时间后重新发送，如果还堵塞，等待时间指数增长，再次发送，直到网络从新疏通。</li><li>交换机： 为了使得同一载体中的计算机少一点，用交换机将同一个局域网分割成两个更小的局域网。互联网就是这样组成的。</li><li>路由： 从一台计算机到另外一台计算机路径一般要好几条，从途中也会经过很多点，可以根据实际情况（比如有条不能用了）选择不同的路由到达目的地，使得通信更可靠，更能容错。一些机构，如军队会购买专有网络连接到数据中心。<ul><li>跳数：消息沿着路由跳转的次数，跳数会记录在消息中，如果哪条消息跳数很高，就说明路由出现了错误。可以用 traceroute 查看跳转的次数</li></ul></li><li>数据包： 从一台计算机发送信息到另外一台计算机的数据我们称之为报文，但报文可能会很大，所以一个报文没传递完时会占用其中一条路，导致后面的报文阻塞。解决方法是将报文拆分为很小的数据包传递</li></ul><h4 id="一些协议"><a href="#一些协议" class="headerlink" title="一些协议"></a>一些协议</h4><ul><li><code>IP</code> (internet protocol): 网络上定位计算机，将数据发给指定的计算机。定义了报文的格式。</li><li><code>UDP</code> : 计算机接收到数据后，通过端口号发给应用程序。典型特征：“端口号”、“校验和”。数据丢失没有修复措施</li><li><code>TCP</code> : 优化后的 <code>UDP</code> ，也具有 “端口号”、“校验和” ， 同时还具有 “数据包有序性”、“数据包接受后发送确认码” … so, <code>TCP</code> 可以处理乱序和丢失数据包，没有接收到确认码就重发，并根据网络情况调整同时发送数据包的个数，即传输 速率</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li><code>DNS</code> (domain name system) :值得一提的是，它存储的是树状结构</li><li><code>OSI</code> 七层协议：<ul><li>物理层： 线路里的电信号、无线网络里的无线信号</li><li>数据链路层： 负责操控 “物理层” 。 有： MAC 地址、碰撞检测、指数退避（如：一个局域网中的不同计算机使用同一载体传输数据时，相互堵塞，各个计算机会等待随机时间后重新发送，如果还堵塞，等待时间指数增长，再次发送，直到网络从新疏通。）</li><li>网络层： 负责报文交换和路由</li><li>传输层： UDP/TCP</li><li>会话层: 用 UDP/TCP 创建连接，传递信息，然后关闭连接，这个过程就是会话。 查询 DNS 或看网页时 就会发生这一套流程。</li><li>表示层：</li><li>应用层：</li></ul></li><li>反向链接：连接到该网页的链接。用来判断网页质量，如果反向链接多，说明质量高。搜索引擎刚出现时有人通过在网页里添加各种关键字（但无实际内容）来欺骗搜索引擎，后面 google 优化算法，通过反向链接来推荐网页</li></ul><h3 id="计算机安全"><a href="#计算机安全" class="headerlink" title="计算机安全"></a>计算机安全</h3>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;看 &lt;a href&gt;Crash Course&lt;/a&gt; 得到的一部分知识。讲的真好，翻译的也真好。&lt;/p&gt;&lt;/blockquote&gt;&lt;h3 id=&quot;集成电路IC&quot;&gt;&lt;a href=&quot;#集成电路IC&quot; class=&quot;headerlink&quot; title=&quot;集成电路IC&quot;&gt;&lt;/a&gt;集成电路IC&lt;/h3&gt;&lt;p&gt;每两年左右，随着材料和制造技术的发展，同样大小的空间，IC能塞进两倍数量的晶体管。这就是 &lt;strong&gt;摩尔定律&lt;/strong&gt;&lt;/p&gt;&lt;h3 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;操作系统可以运行多个程序，但是当我们切换程序的时候我们不希望丢失数据，所以每个程序有指定的内存区。&lt;/li&gt;&lt;li&gt;但有的程序在使用过程中需要更多地内存，所以就会向操作系统提出申请分配更多地内存。如果同意，就会分配另外的内存，但是由于程序都有指定的内存区，所以新分配内存和之前指定的内存就不是连续的。为了解决这个问题，出现了&lt;strong&gt;虚拟内存&lt;/strong&gt;， 虚拟内存和真实内存是映射关系，虽然程序的实际内存是不连续的，但是虚拟内存是连续的，从 0 到 xxxx&lt;/li&gt;&lt;li&gt;由于程序有不同的内存，所以可以&lt;strong&gt;内存保护&lt;/strong&gt;。不同的程序无法访问其他程序的内存。早期的 &lt;code&gt;windows&lt;/code&gt; 由于缺乏内存保护，有时候程序的不当使用会导致系统崩溃，从而引发蓝屏&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;文件系统&quot;&gt;&lt;a href=&quot;#文件系统&quot; class=&quot;headerlink&quot; title=&quot;文件系统&quot;&gt;&lt;/a&gt;文件系统&lt;/h3&gt;&lt;p&gt;文件的本质是一段二进制，通常在前面的几位是文件头，描述了文件的大小，描述了如图片文件的行列数（什么时候换行）…&lt;/p&gt;&lt;ul&gt;&lt;li&gt;为了方便扩展文件大小，硬盘上分为一个个存储块，每个文件占用一个或多个存储块，文件占用的存储块随着文件顺序排列，当文件变大的时候分配新的未使用的存储快&lt;/li&gt;&lt;li&gt;为了记录文件所对应存储快，文件同层下会有一个目录文件，记录了当前目录下所有文件的相关信息：创建时间、修改时间、是否是目录、所在的存储块…&lt;ul&gt;&lt;li&gt;&lt;code&gt;windows&lt;/code&gt; 删除文件的时候其实只是删除了目录文件下对该文件的记录，让我们无法看到，而没有在在硬盘上的删除该文件。所以我们可以通过有些工具恢复删除的文件&lt;/li&gt;&lt;li&gt;&lt;code&gt;windows&lt;/code&gt; 上同一块存储上移动文件特别快，原因是因为只需要在原来目录下的目录文件中删除该文件信息，然后再目标目录下的目录文件中添加该文件信息即可。而不是在存储结构上真实的移动&lt;/li&gt;&lt;li&gt;&lt;code&gt;windows&lt;/code&gt; 在多次进行文件的删除、修改、迁移之后，会使得很多文件在存储上占用的存储块都是不连续的。而 &lt;strong&gt;碎片整理&lt;/strong&gt; 就是从新让文件在存储上顺序排列的过程（ &lt;code&gt;SSD&lt;/code&gt; 不需要 &lt;strong&gt;碎片整理&lt;/strong&gt; ）&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;压缩&quot;&gt;&lt;a href=&quot;#压缩&quot; class=&quot;headerlink&quot; title=&quot;压缩&quot;&gt;&lt;/a&gt;压缩&lt;/h3&gt;&lt;p&gt;图片颜色用 红绿蓝 三种颜色合成表示，每个颜色都是 1 个字节， 所以一个 16px 的图片 占用的内存是 16 * 3 = 48 字节。我们可以用以下方法实现减少内存。&lt;br&gt;
    
    </summary>
    
      <category term="杂说" scheme="https://jintang.github.io/categories/%E6%9D%82%E8%AF%B4/"/>
    
    
      <category term="计算机知识" scheme="https://jintang.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>flutter 父子通信</title>
    <link href="https://jintang.github.io/2019/04/02/flutter-%E7%88%B6%E5%AD%90%E9%80%9A%E4%BF%A1/"/>
    <id>https://jintang.github.io/2019/04/02/flutter-父子通信/</id>
    <published>2019-04-02T09:28:22.000Z</published>
    <updated>2019-06-11T02:08:13.961Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>很早之前看过一句话，最近又重新看到。一个程序员，应该花80%的时间做代码设计、画UML图、画时序图，20%的时间写code和debug。而我恰恰相反，是不是得改变一下做法了？</p></blockquote><p><code>flutter</code> 做出来的 App 性能非常好，比 <code>react-native</code> 好太多了，基本和原生一样。<code>flutter</code> 里面的组件叫做 <code>Widget</code> ，名称不同，思想一样，下面是一些组件通信的技巧。</p><h3 id="子组件调用父组件的函数"><a href="#子组件调用父组件的函数" class="headerlink" title="子组件调用父组件的函数"></a>子组件调用父组件的函数</h3><p>这个简单，父组件给子组件传递回调函数参数，子组件在需要的地方调用传进来的回调函数即可</p><h3 id="父组件调用子组件的函数"><a href="#父组件调用子组件的函数" class="headerlink" title="父组件调用子组件的函数"></a>父组件调用子组件的函数</h3><h4 id="globalKey"><a href="#globalKey" class="headerlink" title="globalKey"></a>globalKey</h4><p>类似于 <code>vue</code> 中的 <code>refs</code> ， 可以直接获取子组件 <code>state</code> 的引用</p><p>示例代码：</p><p><code>main.dart</code>:<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'package:flutter/material.dart'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 创建 globalKey</span></span><br><span class="line">GlobalKey&lt;HomePageState&gt; globalKey = GlobalKey();</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyApp</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> MaterialApp(</span><br><span class="line">      home: Scaffold(</span><br><span class="line">        appBar: AppBar(</span><br><span class="line">          leading: IconButton(</span><br><span class="line">            icon: Icon(Icons.help),</span><br><span class="line">            onPressed: () &#123;</span><br><span class="line">              <span class="comment">// 3. 通过 globalKey 的 currentState 获取方法</span></span><br><span class="line">             globalKey.currentState.methodA();</span><br><span class="line">            &#125;,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">        <span class="comment">// 2. 给子组件传递一个 globalKey</span></span><br><span class="line">        body: HomePage(key: globalKey),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><p><code>home.dart</code>:<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePage</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  HomePage(&#123;Key key&#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  HomePageState createState() =&gt; HomePageState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomePageState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">HomePage</span>&gt; </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> methodA() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>注意：</strong> <code>GlobalKey</code> 使用在 使用 <code>AutomaticKeepAliveClientMixin</code> 的 <code>TabBarView</code> 上会出问题。假如有 3 个 tab ，如果从第1个直接切换到第3个，会提示使用了重复的 <code>GlobalKey</code>。我是用的是 <code>flutter 1.0</code> ，此问题还没有解决，参见<a href="https://github.com/flutter/flutter/issues/27010" target="_blank" rel="noopener">这儿</a>。 <code>flutter 1.2</code> 已经出来了，但是此 <code>Issue</code> 还没有关闭</p><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p>订阅管理模式，类似 <strong>EventBus</strong> 。通过 <code>sink</code> 发送事件，<code>listen()</code> 监听事件。</p><p>严格来说，这不是父调用子函数,而是通过事件监听。</p><p>示例代码： 注意查看上面代码有数字标志注释的代码</p><p><code>home.dart</code>:<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  HomeState createState =&gt; HomeState();</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HomeState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">Home</span>&gt; <span class="title">with</span> <span class="title">SingleTickerProviderStateMixin</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> _tabIndex = <span class="number">0</span>;</span><br><span class="line">  TabController controller;</span><br><span class="line">  <span class="keyword">static</span> StreamController streamController;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 1. 创建一个 广播 streamController ，可以订阅多个事件。（还可以创建 单订阅 stream）</span></span><br><span class="line">    streamController = StreamController.broadcast();</span><br><span class="line">    ConnectionListener.init(context);</span><br><span class="line">    controller = <span class="keyword">new</span> TabController(length: <span class="number">3</span>, vsync: <span class="keyword">this</span>)</span><br><span class="line">      ..addListener(() &#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          <span class="keyword">this</span>._tabIndex = controller.index;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// indexIsChanging是为了防止切换tab时触发两次</span></span><br><span class="line">        <span class="keyword">if</span> (controller.indexIsChanging &amp;&amp; controller.index &lt; <span class="number">2</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (controller.index == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 2. 触发广播， 并传递一个字符串标识符</span></span><br><span class="line">            streamController.sink.add(<span class="string">'refresh_wallet'</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="keyword">void</span> dispose() &#123;</span><br><span class="line">      controller.dispose();</span><br><span class="line">      <span class="comment">// 5. 销毁 streamController</span></span><br><span class="line">      streamController.close();</span><br><span class="line">      <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Widget getTabItem(<span class="built_in">int</span> tabIndex) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      height: ScreenUtil().setHeight(<span class="number">58</span>),</span><br><span class="line">      child: <span class="keyword">new</span> Tab(</span><br><span class="line">        child: Text(<span class="string">'tab'</span> + tabIndex.toString()),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">      <span class="keyword">return</span>  <span class="keyword">new</span> Scaffold(</span><br><span class="line">        body: <span class="keyword">new</span> TabBarView(</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            WalletTab(streamController: streamController),</span><br><span class="line">            FinancialTab(),</span><br><span class="line">            UserTab()</span><br><span class="line">          ],</span><br><span class="line">          controller: controller,</span><br><span class="line">        ),</span><br><span class="line">        bottomNavigationBar: <span class="keyword">new</span> Material(</span><br><span class="line">          child: <span class="keyword">new</span> TabBar(</span><br><span class="line">            tabs: [</span><br><span class="line">              getTabItem(<span class="number">0</span>),</span><br><span class="line">              getTabItem(<span class="number">1</span>),</span><br><span class="line">              getTabItem(<span class="number">2</span>),</span><br><span class="line">            ],</span><br><span class="line">            controller: controller,</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><code>walletTab.dart</code>（ <code>home</code> 下的第一个 <code>tab</code> ） :<br></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WalletTab</span> <span class="keyword">extends</span> <span class="title">StatefulWidget</span> </span>&#123;</span><br><span class="line">  StreamController streamController;</span><br><span class="line">  WalletTab(&#123;<span class="keyword">this</span>.streamController&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  WalletTabState createState() =&gt; <span class="keyword">new</span> WalletTabState();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WalletTabState</span> <span class="keyword">extends</span> <span class="title">State</span>&lt;<span class="title">WalletTab</span>&gt; <span class="title">with</span> <span class="title">AutomaticKeepAliveClientMixin</span></span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="built_in">bool</span> <span class="keyword">get</span> wantKeepAlive =&gt; <span class="keyword">true</span>;</span><br><span class="line">  StreamSubscription streamSubscription;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  initState() &#123;</span><br><span class="line">    <span class="keyword">super</span>.initState();</span><br><span class="line">    <span class="comment">// 3. 订阅广播，并判断标识符是否为 'refresh_wallet'</span></span><br><span class="line">    streamSubscription = widget.streamController.stream.listen((value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="string">'refresh_wallet'</span>) &#123;</span><br><span class="line">        <span class="comment">// do something...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  dispose() &#123;</span><br><span class="line">    <span class="comment">// 4. 销毁广播订阅</span></span><br><span class="line">    streamSubscription.cancel();</span><br><span class="line">    <span class="keyword">super</span>.dispose();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Container(</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="flutter-状态管理"><a href="#flutter-状态管理" class="headerlink" title="flutter 状态管理"></a>flutter 状态管理</h3><p>下面这些暂时没用到，但经常看到，功能非常强大，先做了解记录一下。</p><h4 id="InheritedWidget"><a href="#InheritedWidget" class="headerlink" title="InheritedWidget"></a>InheritedWidget</h4><p>统一状态管理，类似 <code>Redux</code> （ <code>flutter</code> 中可以使用 <code>Redux</code> ）、 <code>Vuex</code> ，子组件可以通过 <code>of()</code> 获取祖先的 <code>state</code></p><h4 id="ScopedModel"><a href="#ScopedModel" class="headerlink" title="ScopedModel"></a>ScopedModel</h4><p>用于给子组件传递 <code>data</code> ，不用层层传递</p><h4 id="BLOC"><a href="#BLOC" class="headerlink" title="BLOC"></a>BLOC</h4><p><code>Stream</code> 在 <code>Flutter</code> 中的最佳实践</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;很早之前看过一句话，最近又重新看到。一个程序员，应该花80%的时间做代码设计、画UML图、画时序图，20%的时间写code和debug。而我恰恰相反，是不是得改变一下做法了？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;code&gt;flutter&lt;/code&gt; 做出来的 App 性能非常好，比 &lt;code&gt;react-native&lt;/code&gt; 好太多了，基本和原生一样。&lt;code&gt;flutter&lt;/code&gt; 里面的组件叫做 &lt;code&gt;Widget&lt;/code&gt; ，名称不同，思想一样，下面是一些组件通信的技巧。&lt;/p&gt;&lt;h3 id=&quot;子组件调用父组件的函数&quot;&gt;&lt;a href=&quot;#子组件调用父组件的函数&quot; class=&quot;headerlink&quot; title=&quot;子组件调用父组件的函数&quot;&gt;&lt;/a&gt;子组件调用父组件的函数&lt;/h3&gt;&lt;p&gt;这个简单，父组件给子组件传递回调函数参数，子组件在需要的地方调用传进来的回调函数即可&lt;/p&gt;&lt;h3 id=&quot;父组件调用子组件的函数&quot;&gt;&lt;a href=&quot;#父组件调用子组件的函数&quot; class=&quot;headerlink&quot; title=&quot;父组件调用子组件的函数&quot;&gt;&lt;/a&gt;父组件调用子组件的函数&lt;/h3&gt;&lt;h4 id=&quot;globalKey&quot;&gt;&lt;a href=&quot;#globalKey&quot; class=&quot;headerlink&quot; title=&quot;globalKey&quot;&gt;&lt;/a&gt;globalKey&lt;/h4&gt;&lt;p&gt;类似于 &lt;code&gt;vue&lt;/code&gt; 中的 &lt;code&gt;refs&lt;/code&gt; ， 可以直接获取子组件 &lt;code&gt;state&lt;/code&gt; 的引用&lt;/p&gt;&lt;p&gt;示例代码：&lt;/p&gt;&lt;p&gt;&lt;code&gt;main.dart&lt;/code&gt;:&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight dart&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;package:flutter/material.dart&#39;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 1. 创建 globalKey&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;GlobalKey&amp;lt;HomePageState&amp;gt; globalKey = GlobalKey();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;MyApp&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;StatelessWidget&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;meta&quot;&gt;@override&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Widget build(BuildContext context) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; MaterialApp(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      home: Scaffold(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        appBar: AppBar(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          leading: IconButton(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            icon: Icon(Icons.help),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            onPressed: () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;              &lt;span class=&quot;comment&quot;&gt;// 3. 通过 globalKey 的 currentState 获取方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;             globalKey.currentState.methodA();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          ),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        ),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// 2. 给子组件传递一个 globalKey&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        body: HomePage(key: globalKey),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      ),&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="flutter" scheme="https://jintang.github.io/categories/flutter/"/>
    
    
      <category term="flutter" scheme="https://jintang.github.io/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>机器学习算法 — 奇异值分解</title>
    <link href="https://jintang.github.io/2019/03/26/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%20%E2%80%94%20%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3/"/>
    <id>https://jintang.github.io/2019/03/26/机器学习算法 — 奇异值分解/</id>
    <published>2019-03-26T14:22:13.000Z</published>
    <updated>2019-07-10T07:37:22.201Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>机器学习算法可以分为三大类：监督学习、无监督学习和强化学习。</p><ul><li>监督学习可用于一个特定的数据集（训练集）具有某一属性（标签），但是其他数据没有标签或者需要预测标签的情况。</li><li>无监督学习可用于给定的没有标签的数据集（数据不是预分配好的），目的就是要找出数据间的潜在关系。</li><li>强化学习位于这两者之间，每次预测都有一定形式的反馈，但是没有精确的标签或者错误信息。</li></ul></blockquote><p>有几种常见的关于监督学习和无监督学习的算法。比如决策树、朴素贝叶斯分类、最小二乘法（是一种计算线性回归的方法）。在这儿，主要介绍一种无监督学习的算法：奇异值分解（SVD）, 在线性代数中，SVD 是复杂矩阵的因式分解。</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="矩阵的特征值和特征向量"><a href="#矩阵的特征值和特征向量" class="headerlink" title="矩阵的特征值和特征向量"></a>矩阵的特征值和特征向量</h4><p>设 A 是 n 阶矩阵，若存在数 $\lambda$ 及非零的 n 维列向量 $\nu$ ,使得<br>$$A\nu=\lambda\nu$$<br>成立，则称$\lambda$是矩阵 A 的<strong>特征值</strong>，称非零向量 $\nu$ 是矩阵 A 属于特征值 $\lambda$ 的<strong>特征向量</strong><br><br><a id="more"></a><br><strong>计算步骤：</strong></p><ol><li>计算 A 的特征多项式 $|\lambda I- A|$</li><li>判断特征方程 $|\lambda I- A| = 0$ 有没有根。由行列式计算可知，行列式$|\lambda I- A|$的值是n次多项式。如果没有根，则 A 没有特征值，从而也没有特征向量。如果 $|\lambda I- A|$ 有根，共有 n 个根（其中可能有复根，也可能有重根），这些根就是 A 的全部特征值。进行下一步</li><li>对于 A 的每一个特征值 $\lambda_j$ ，求解齐次线性方程组 $|\lambda_j I - A|X = 0$，则方程组的每一个非零解都是A的属于特征值$\lambda_j$的特征向量（说明有无穷多个）</li></ol><p><strong>举个例子：</strong><br>设 $A=\left[ \begin{array}{cc} 1 &amp; 2 \\ 2 &amp; 4 \\ \end{array} \right]$<br>A的特征多项式为 $|\lambda I- A| = \left[ \begin{array}{cc} \lambda - 1 &amp; -2 \\ -2 &amp; \lambda - 4 \\ \end{array} \right] = \lambda(\lambda - 5)$<br>得到特征值 $\lambda_1 = 0, \lambda_2 = 5$<br>将 $\lambda_1$ 带入 $|\lambda_j I - A|X = 0$ :<br>$$|\lambda_j I - A| = \left[ \begin{array}{cc} -1 &amp; -2 \\ -2 &amp; -4 \\ \end{array} \right] = \left[ \begin{array}{cc} 1 &amp; 2 \\ 0 &amp; 0 \\ \end{array} \right]$$<br>故 $\lambda_1$ 的特征向量的基础解系为 $\left[ \begin{array}{cc} -2 &amp; 1 \end{array} \right]$</p><p>将 $\lambda_2$ 带入 $|\lambda_j I - A|X = 0$ :<br>$$|\lambda_j I - A| = \left[ \begin{array}{cc} 4 &amp; -2 \\ -2 &amp; 1 \\ \end{array} \right] = \left[ \begin{array}{cc} -2 &amp; 1 \\ 0 &amp; 0 \\ \end{array} \right]$$<br>故 $\lambda_1$ 的特征向量的基础解系为 $\left[ \begin{array}{cc} 1 &amp; 2 \end{array} \right]$</p><h4 id="对角化分解"><a href="#对角化分解" class="headerlink" title="对角化分解"></a>对角化分解</h4><p>给定一个大小为$m\times m$的矩阵A（方阵），其对角化分解可以写成<br>$$A=U\Lambda U^{-1}$$<br>其中，U的每一列都是特征向量，$\Lambda$对角线上的元素是从大到小排列的特征值，若将U记作$U=\left( \vec{u}_1,\vec{u}_2,…,\vec{u}_m \right)$ ，则:<br>$$AU=A\left(\vec{u}_1,\vec{u}_2,…,\vec{u}_m\right)=\left(\lambda_1 \vec{u}_1,\lambda_2 \vec{u}_2,…,\lambda_m \vec{u}_m\right)$$<br>$$=\left(\vec{u}_1,\vec{u}_2,…,\vec{u}_m\right) \left[ \begin{array}{ccc} \lambda_1 &amp; \cdots &amp; 0 \\ \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; \cdots &amp; \lambda_m \\ \end{array} \right]$$<br>$$\Rightarrow AU=U\Lambda \Rightarrow A=U\Lambda U^{-1}$$</p><p>更为特殊的是，当矩阵A是一个对称矩阵时，则存在一个对称对角化分解，即</p><p>$$A=Q\Lambda Q^T$$</p><p>其中，Q的每一列都是相互正交的特征向量，且是单位向量，$\Lambda$对角线上的元素是从大到小排列的特征值。</p><p>当然，将矩阵Q记作$Q=\left(\vec{q}_1,\vec{q}_2,…,\vec{q}_m\right)$，则矩阵A也可以写成如下形式：</p><p>$$A=\lambda_1 \vec{q}_1\vec{q}_1^T+\lambda_2 \vec{q}_2\vec{q}_2^T+…+\lambda_m \vec{q}_m\vec{q}_m^T$$</p><p><strong>举个例子：</strong><br>如给定一个大小为$2\times 2$的矩阵$A=\left[ \begin{array}{cc} 2 &amp; 1 \\ 1 &amp; 2 \\ \end{array} \right]$，根据</p><p>$\left|\lambda I-A\right|=\left| \begin{array}{cc} \lambda-2 &amp; -1 \\ -1 &amp; \lambda-2 \\ \end{array} \right|=0$求得特征值为$\lambda_1=3，\lambda_2=1$，相应地，</p><p>$\vec{q}_1=\left[ \begin{array}{cc} \frac{\sqrt{2}}{2} \\ \frac{\sqrt{2}}{2} \\ \end{array} \right], \vec{q}_2=\left[ \begin{array}{cc} - \frac{\sqrt{2}}{2} \\ \frac{\sqrt{2}}{2} \\ \end{array} \right]$，则</p><p>$$A=\lambda_1 \vec{q}_1\vec{q}_1^T+\lambda_2 \vec{q}_2\vec{q}_2^T =\left[ \begin{array}{cc} 2 &amp; 1 \\ 1 &amp; 2 \\ \end{array} \right].$$</p><p>这样，我们就很容易地得到了矩阵A的对称对角化分解。</p><p><strong>与奇异值分解的关系：</strong>对于正定对称矩阵而言，奇异值分解和对称对角化分解结果相同。</p><h3 id="SVD的定义"><a href="#SVD的定义" class="headerlink" title="SVD的定义"></a>SVD的定义</h3><p>设我们的矩阵A是一个m×n的矩阵，那么我们定义矩阵A的SVD为：<br>$$A=UΣV^T$$</p><p>其中U是一个m×m的矩阵，Σ是一个m×n的矩阵，除了主对角线上的元素以外全为0，主对角线上的每个元素都称为奇异值，V是一个n×n的矩阵。U和V都是酉矩阵，即满足$U^T U=I,V^T V=I$</p><p><strong>如何求取：</strong></p><ul><li>如果我们将A和A的转置做矩阵乘法，那么会得到m×m的一个方阵$AA^T$。既然$AA^T$是方阵，那么我们就可以进行特征分解，得到的特征值和特征向量满足下式：<br>$$(AA^T)\nu_i=λ_i \nu_i$$<br>这样我们就可以得到矩阵$AA^T$的m个特征值和对应的m个特征向量u了。将$AA^T$的所有特征向量张成一个m×m的矩阵U，就是我们SVD公式里面的U矩阵了。一般我们将U中的每个特征向量叫做A的左奇异向量。</li><li>将A的转置和A做矩阵乘法，那么会得到n×n的一个方阵$A^T A$。既然$A^T A$是方阵，那么我们就可以进行特征分解，得到的特征值和特征向量满足下式：<br>$$(A^T A)\nu_i=\lambda_i \nu_i$$<br>这样我们就可以得到矩阵 $A^T A$ 的n个特征值和对应的n个特征向量$\nu$了。将$A^T A$的所有特征向量张成一个n×n的矩阵V，就是我们SVD公式里面的V矩阵了。一般我们将V中的每个特征向量叫做A的右奇异向量。</li><li>由于Σ除了对角线上是奇异值其他位置都是0，那我们只需要求出每个奇异值σ就可以了。<br>$$A=UΣV^T ⇒ AV=UΣV^T V ⇒ AV=UΣ⇒ A\nu_i=σ_i u_i ⇒ σi=A\nu_i /u_i$$<br>特征值和奇异值满足此关系：$σ_i=\sqrtλ_i$ ,可以通过计算$A^T A$的特征值取平方根来求奇异值（<strong>注意，$AA^T$ 和 $A^T A$ 的特征值相同，<a href="https://link.zhihu.com/?target=https%3A//math.stackexchange.com/questions/1249497/largest-eigenvalues-of-aa-equals-to-aa" target="_blank" rel="noopener">证明链接</a> </strong>）</li></ul><p><strong>求取步骤：</strong></p><ol><li>计算 $AA^T$ 和 $A^T A$；</li><li>分别计算 $AA^T$ 和 $A^T A$ 的特征向量及其特征值；</li><li>$AA^T$ 的特征向量组成 U；而 $A^T A$ 的特征向量组成 V；</li><li>对 $AA^T$ 和 $A^T A$ 的非零特征值求平方根，对应上述特征向量的位置，填入 Σ 的对角元。</li></ol><p><strong>举个例子：</strong><br>设 $A=\left[ \begin{array}{cc} 2 &amp; 4 \\ 1 &amp; 3 \\ 0 &amp; 0 \\ 0 &amp; 0 \\ \end{array} \right]$</p><p><em>首先</em>，计算 $AA^T$:<br>$$AA^T = \left[ \begin{array}{cc} 2 &amp; 4 \\ 1 &amp; 3 \\ 0 &amp; 0 \\ 0 &amp; 0 \\ \end{array} \right] \left[ \begin{array}{cc} 2 &amp; 1 &amp; 0 &amp; 0 \\ 4 &amp; 3 &amp; 0 &amp; 0 \\ \end{array} \right] = \left[ \begin{array}{cc} 20 &amp; 14 &amp; 0 &amp; 0 \\ 14 &amp; 10 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 0 \\ \end{array} \right]$$<br>根据特征向量方程$|\lambda I- A| = 0$:<br>$$\left| \begin{array}{cc} \lambda - 20 &amp; -14 &amp; 0 &amp; 0 \\ -14 &amp; \lambda - 10 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; \lambda &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; \lambda \\ \end{array} \right| = \left| \begin{array}{cc} \lambda - 20 &amp; - 14 \\ - 14 &amp; \lambda - 10 \\ \end{array} \right| \left| \begin{array}{cc} \lambda &amp; 0 \\ 0 &amp; \lambda \\ \end{array} \right| = 0$$</p><p>即: $ ((λ-20)(λ-10)−196)λ^2 = 0$， 得到特征值：$ λ_1=λ_2=0, λ_3=15+\sqrt 221≈29.866, λ_4=15− \sqrt 221≈0.134$</p><p>根据特征值代入原方程，可解得对应的特征向量。这些特征向量即作为列向量，形成矩阵:<br>$$U=\left[ \begin{array}{cc} 0.82 &amp; -0.58 &amp; 0 &amp; 0 \\ 0.58 &amp; 0.82 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{array} \right]$$</p><p><em>同理可得</em>：</p><p>$$V=\left[ \begin{array}{cc} 0.40 &amp; -0.91 \\ 0.91 &amp; 0.40 \\ \end{array} \right] $$</p><p><em>然后</em>， Σ 上的对角线元素由 $AA^T$ 的特征值的算术平方根组成</p><p>$$Σ=\left[ \begin{array}{cc} 5.46 &amp; 0 \\ 0 &amp; 0.37 \\ 0 &amp; 0 \\ 0 &amp; 0 \\ \end{array} \right] $$</p><p><em>最后</em>, 得到 A 的 SVD 分解：<br>$$\left[ \begin{array}{cc} 2 &amp; 4 \\ 1 &amp; 3 \\ 0 &amp; 0 \\ 0 &amp; 0 \\ \end{array} \right] ≈ \left[ \begin{array}{cc} 0.82 &amp; -0.58 &amp; 0 &amp; 0 \\ 0.58 &amp; 0.82 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ \end{array} \right] \left[ \begin{array}{cc} 5.46 &amp; 0 \\ 0 &amp; 0.37 \\ 0 &amp; 0 \\ 0 &amp; 0 \\ \end{array} \right] \left[ \begin{array}{cc} 0.40 &amp; -0.91 \\ 0.91 &amp; 0.40 \\ \end{array} \right] $$</p><p><strong>结果分析：</strong></p><ul><li>上述分解中会构建出一个矩阵∑，该矩阵只有对角元素，其他元素均为0(近似于0)。另一个惯例就是，∑的对角元素是从大到小排列的。这些对角元素称为奇异值。</li><li>奇异值与特征值(PCA 数据中重要特征)是有关系的。这里的奇异值就是矩阵 $AA^T$ 特征值的平方根。</li><li>普遍的事实：在某个奇异值的数目(r 个=&gt;奇异值的平方和累加到总值的90%以上)之后，其他的奇异值都置为0(近似于0)。这意味着数据集中仅有 r 个重要特征，而其余特征则都是噪声或冗余特征。</li></ul><h3 id="SVD的性质"><a href="#SVD的性质" class="headerlink" title="SVD的性质"></a>SVD的性质</h3><p>对于奇异值,它跟我们特征分解中的特征值类似，在奇异值矩阵中也是按照从大到小排列，而且奇异值的减少特别的快，在很多情况下，前10%甚至1%的奇异值的和就占了全部的奇异值之和的99%以上的比例。</p><p>也就是说，我们也可以用最大的k个的奇异值和对应的左右奇异向量来近似描述矩阵。也就是说：</p><p>其中k要比n小很多，也就是一个大的矩阵A可以用三个小的矩阵表示</p><ul><li>$U_{m×k}$,</li><li>$Σ_{k×k}$</li><li>$V^T_{k\times n}$<br>如下图所示，现在我们的矩阵A只需要灰色的部分的三个小矩阵就可以近似描述了。<br><img src="https://tang-blog-1257996120.cos.ap-chengdu.myqcloud.com/svd.png" alt="k"></li></ul><p>由于这个重要的性质，SVD可以用于PCA降维，来做数据压缩和去噪。也可以用于推荐算法，将用户和喜好对应的矩阵做特征分解，进而得到隐含的用户需求来做推荐。同时也可以用于NLP中的算法，比如潜在语义索引（LSI）。</p><h3 id="奇异值分解的应用"><a href="#奇异值分解的应用" class="headerlink" title="奇异值分解的应用"></a>奇异值分解的应用</h3><ol><li>隐性语义检索<br>隐性语义索引：矩阵 = 文档 + 词语<br><img src="https://i.imgur.com/EPoEEET.png" alt="yuyisuoyin"></li><li>推荐系统<ul><li>利用 SVD 从数据中构建一个主题空间。</li><li>再在该空间下计算其相似度。(从高维-低维空间的转化，在低维空间来计算相似度，SVD 提升了推荐系统的效率。)</li></ul></li><li>图像压缩<br>例如：32<em>32=1024 =&gt; 32</em>2+2<em>1+32</em>2=130(2*1表示去掉了除对角线的0), 几乎获得了10倍的压缩比。</li></ol><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><ol><li>逆矩阵（inverse matrix）：<br>又称反矩阵。在线性代数中，给定一个n阶方阵 A，若存在一n阶方阵 B ，使得 $AB=BA=I_n$，其中 $I_n$ 为n阶单位矩阵，则称 A 是可逆的，且 B 是 A的逆矩阵，记作 $A^{-1}$。</li></ol><p>只有方阵（n×n的矩阵）才可能有逆矩阵。若方阵 A 的逆矩阵存在，则称 A 为非奇异方阵或可逆方阵。</p><ol><li><p>向量正交：指它们的内积等于零.治元前面已经讲过了。</p></li><li><p>单位矩阵：<br>n阶单位矩阵，是一个 $n * n$ 的方形矩阵，其主对角线元素为1，其余元素为0。单位矩阵以 $I<em>n$ 表示, 如果阶数可忽略，也可简记为 I（或者E）。 如:<br>$$<br>I</em>{2}={\begin{bmatrix}1&amp;0\\0&amp;1\end{bmatrix}}<br>$$</p></li><li>行列式值得计算（必须是方阵）：<br>2 X 2 矩阵：<br>$$A = \left[ \begin{array}{cc} 2 &amp; 1 \\ 1 &amp; 2 \\ \end{array} \right]$$</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;机器学习算法可以分为三大类：监督学习、无监督学习和强化学习。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;监督学习可用于一个特定的数据集（训练集）具有某一属性（标签），但是其他数据没有标签或者需要预测标签的情况。&lt;/li&gt;&lt;li&gt;无监督学习可用于给定的没有标签的数据集（数据不是预分配好的），目的就是要找出数据间的潜在关系。&lt;/li&gt;&lt;li&gt;强化学习位于这两者之间，每次预测都有一定形式的反馈，但是没有精确的标签或者错误信息。&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;有几种常见的关于监督学习和无监督学习的算法。比如决策树、朴素贝叶斯分类、最小二乘法（是一种计算线性回归的方法）。在这儿，主要介绍一种无监督学习的算法：奇异值分解（SVD）, 在线性代数中，SVD 是复杂矩阵的因式分解。&lt;/p&gt;&lt;h3 id=&quot;基础知识&quot;&gt;&lt;a href=&quot;#基础知识&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h3&gt;&lt;h4 id=&quot;矩阵的特征值和特征向量&quot;&gt;&lt;a href=&quot;#矩阵的特征值和特征向量&quot; class=&quot;headerlink&quot; title=&quot;矩阵的特征值和特征向量&quot;&gt;&lt;/a&gt;矩阵的特征值和特征向量&lt;/h4&gt;&lt;p&gt;设 A 是 n 阶矩阵，若存在数 $\lambda$ 及非零的 n 维列向量 $\nu$ ,使得&lt;br&gt;$$A\nu=\lambda\nu$$&lt;br&gt;成立，则称$\lambda$是矩阵 A 的&lt;strong&gt;特征值&lt;/strong&gt;，称非零向量 $\nu$ 是矩阵 A 属于特征值 $\lambda$ 的&lt;strong&gt;特征向量&lt;/strong&gt;&lt;br&gt;&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://jintang.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="奇异值分解" scheme="https://jintang.github.io/tags/%E5%A5%87%E5%BC%82%E5%80%BC%E5%88%86%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>线性代数学习</title>
    <link href="https://jintang.github.io/2019/03/19/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%AD%A6%E4%B9%A0/"/>
    <id>https://jintang.github.io/2019/03/19/线性代数学习/</id>
    <published>2019-03-19T15:29:56.000Z</published>
    <updated>2019-07-10T07:44:34.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>理解n阶行列式的概念，正确的计算三阶、四阶行列式，还有简单的n阶行列式的值</p><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>按行（列）展开公式，通过降阶来实现。但是在展开之前往往先通过对行列式的恒等变形，以在新的行列式中能构造出叫多的0或有公因式，从而简化计算。</p><p>常用技巧有：三角化法、递推法、数学归纳法、公式法等</p><h3 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h3><ol><li>把某行的k倍加到另一行，行列式的值不变</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;目标&quot;&gt;&lt;a href=&quot;#目标&quot; class=&quot;headerlink&quot; title=&quot;目标&quot;&gt;&lt;/a&gt;目标&lt;/h3&gt;&lt;p&gt;理解n阶行列式的概念，正确的计算三阶、四阶行列式，还有简单的n阶行列式的值&lt;/p&gt;&lt;h3 id=&quot;基本方法&quot;&gt;&lt;a href=&quot;#基本方法&quot;
    
    </summary>
    
      <category term="机器学习" scheme="https://jintang.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="线性代数" scheme="https://jintang.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>js发布订阅者模式简单实现</title>
    <link href="https://jintang.github.io/2019/02/11/js%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E8%80%85%E6%A8%A1%E5%BC%8F%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>https://jintang.github.io/2019/02/11/js发布订阅者模式简单实现/</id>
    <published>2019-02-11T10:00:07.000Z</published>
    <updated>2019-07-10T07:51:37.611Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>之前在对比 <code>react</code> 和 <code>vue</code> 的时候，发现 <code>vue</code> 有 <code>EventBus</code> 处理非父子组件通信， 而 <code>react</code> 推荐使用 <a href="https://github.com/mroderick/PubSubJS" target="_blank" rel="noopener">PubSub.js</a> 实现。这种发布订阅者模式应用广泛，<code>vue</code> 根据 <code>Object.defineProperty</code> 实现双向绑定也是一种发布订阅者模式。下面是根据 <a href="https://github.com/mroderick/PubSubJS" target="_blank" rel="noopener">PubSub.js</a> 简化后的版本。</p></blockquote><p><a href="https://gist.github.com/jintangWang/35d96dc2491a45a9a5a674305dc374cf" target="_blank" rel="noopener">简化PubSub</a></p><p><a href="https://jsfiddle.net/jintang/xuk9Lemj/" target="_blank" rel="noopener">测试demo</a>, 查看 log 即可看到效果</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;之前在对比 &lt;code&gt;react&lt;/code&gt; 和 &lt;code&gt;vue&lt;/code&gt; 的时候，发现 &lt;code&gt;vue&lt;/code&gt; 有 &lt;code&gt;EventBus&lt;/code&gt; 处理非父子组件通信， 而 &lt;code&gt;react&lt;/code&gt; 推
    
    </summary>
    
      <category term="前端" scheme="https://jintang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="javascript" scheme="https://jintang.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>学习vue源码得到的知识</title>
    <link href="https://jintang.github.io/2018/12/10/%E5%AD%A6%E4%B9%A0vue%E6%BA%90%E5%BE%97%E5%88%B0%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86/"/>
    <id>https://jintang.github.io/2018/12/10/学习vue源得到的小知识/</id>
    <published>2018-12-10T09:57:59.000Z</published>
    <updated>2019-07-10T07:45:58.248Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Vue-extend-创建-“Vue”-的-子类"><a href="#Vue-extend-创建-“Vue”-的-子类" class="headerlink" title="Vue.extend(): 创建 “Vue” 的 子类"></a>Vue.extend(): 创建 “Vue” 的 子类</h3><h3 id="window-performance-监控代码性能"><a href="#window-performance-监控代码性能" class="headerlink" title="window.performance: 监控代码性能"></a>window.performance: 监控代码性能</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> perf = inBrowser &amp;&amp; <span class="built_in">window</span>.performance;</span><br><span class="line">mark(<span class="string">'start'</span>)</span><br><span class="line"><span class="comment">// do something</span></span><br><span class="line">mark(<span class="string">'end'</span>)</span><br></pre></td></tr></table></figure><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><ol><li><p>遍历数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = props.length</span><br><span class="line"><span class="keyword">while</span> (i--) &#123;   、</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>js 中一个值与自身都不相等: NaN 。通过下面的方式判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">  <span class="comment">// newVal 是 NaN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>IE11 才开始支持 <code>__proto__</code> , 之前的不支持<br>如何拦截 读取和写入 纯对象/数组</p></li><li><p>缓存一个纯函数: cached 实现？</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Vue-extend-创建-“Vue”-的-子类&quot;&gt;&lt;a href=&quot;#Vue-extend-创建-“Vue”-的-子类&quot; class=&quot;headerlink&quot; title=&quot;Vue.extend(): 创建 “Vue” 的 子类&quot;&gt;&lt;/a&gt;Vue.extend(
    
    </summary>
    
      <category term="前端" scheme="https://jintang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="vue" scheme="https://jintang.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>react-native 之 webview</title>
    <link href="https://jintang.github.io/2018/12/04/react-native-%E4%B9%8B-webview/"/>
    <id>https://jintang.github.io/2018/12/04/react-native-之-webview/</id>
    <published>2018-12-04T08:07:11.000Z</published>
    <updated>2019-07-10T07:53:43.242Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前段时间公司要求写个游戏嵌入到 App 中，我们通过 <code>webview</code> 链接到 App 中，中间遇到了很多坑，在此记录一下。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sourceAndroid = &#123; <span class="attr">uri</span>: <span class="string">'file:///android_asset/trivia-game/index.html'</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> sourceIOS = &#123; <span class="attr">uri</span>: <span class="string">'./trivia-game/index.html'</span> &#125;;</span><br><span class="line">source = Platform.OS === <span class="string">'ios'</span> ? sourceIOS : sourceAndroid;</span><br><span class="line">&lt;WebView</span><br><span class="line">    ref=&#123;( webView ) =&gt; <span class="keyword">this</span>.webView = webView&#125;</span><br><span class="line">    source=&#123; source &#125;</span><br><span class="line">    originWhitelist=&#123;[<span class="string">"file://"</span>, <span class="string">'*'</span>]&#125;</span><br><span class="line">    style=&#123;&#123;<span class="attr">height</span>: <span class="keyword">this</span>.state.webViewHeight&#125;&#125;</span><br><span class="line">    javaScriptEnabled = &#123; <span class="literal">true</span> &#125;</span><br><span class="line">    scrollEnabled = &#123; <span class="literal">false</span> &#125;</span><br><span class="line">    domStorageEnabled = &#123; <span class="literal">true</span> &#125;</span><br><span class="line">    scalesPageToFit = &#123; <span class="literal">true</span> &#125;</span><br><span class="line">    startInLoadingState = &#123; <span class="literal">true</span> &#125;</span><br><span class="line">    renderLoading = &#123; () =&gt; <span class="xml"><span class="tag">&lt;<span class="name">ActivityIndicator</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">    onLoadEnd=&#123; this._onLoadEnd &#125;</span></span><br><span class="line"><span class="xml">    onMessage=&#123; this._onMessage &#125;</span></span><br><span class="line"><span class="xml">    onNavigationStateChange=&#123; this._onNavigationStateChange &#125;</span></span><br><span class="line"><span class="xml">    allowUniversalAccessFromFileURLs=&#123; true &#125;</span></span><br><span class="line"><span class="xml">    mediaPlaybackRequiresUserAction=&#123; false &#125;</span></span><br><span class="line"><span class="xml">/&gt;</span></span><br></pre></td></tr></table></figure><p>官方介绍： <a href="https://reactnative.cn/docs/webview/" target="_blank" rel="noopener">webview</a>，其中像 <code>javaScriptEnabled</code> 这些属性是我们常用的，还有一些不常用但很能填坑的属性下面介绍下</p><h3 id="webview-与-react-native-通信"><a href="#webview-与-react-native-通信" class="headerlink" title="webview 与 react-native 通信"></a>webview 与 react-native 通信</h3><p>目前只能传递字符串</p><h4 id="webview-给-react-native-发消息："><a href="#webview-给-react-native-发消息：" class="headerlink" title="webview 给 react-native 发消息："></a><code>webview</code> 给 <code>react-native</code> 发消息：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.postMessage(<span class="string">'str'</span>)</span><br></pre></td></tr></table></figure><p><code>react-native</code> 通过 <code>onMessage</code> 接受消息：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_onMessage = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log( <span class="string">"On Message"</span>, e.nativeEvent.data );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><h4 id="react-native-给-webview-发消息："><a href="#react-native-给-webview-发消息：" class="headerlink" title="react-native 给 webview 发消息："></a><code>react-native</code> 给 <code>webview</code> 发消息：</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.webView.postMessage(<span class="string">'str'</span>);</span><br></pre></td></tr></table></figure><p><code>webview</code> 接受消息：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener( <span class="string">'message'</span>, event =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(event.data)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><h3 id="自动计算-webview-高度"><a href="#自动计算-webview-高度" class="headerlink" title="自动计算 webview 高度"></a>自动计算 webview 高度</h3><blockquote><p>刚开始我使用的是 <code>onLoadEnd</code> 计算网页高度。当图片加载成功时 <strong>Android</strong> 和 <strong>Ios</strong> 都 OK 。如果有图片加载失败， <strong>Ios</strong> Ok ， <strong>Android</strong> 的高度会计算失败，内容显示不全。<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">_onLoadEnd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> script = <span class="string">`window.postMessage(document.body.scrollHeight)`</span>;</span><br><span class="line">    <span class="keyword">this</span>.webView.injectJavaScript(script);</span><br><span class="line">&#125;;</span><br><span class="line">_onMessage = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> height = <span class="built_in">parseInt</span>(event.nativeEvent.data) || <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (height &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123; <span class="attr">webViewHeight</span>: height &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><p></p></blockquote><p>下面的方案可以修复上面的问题：<br>在 <code>index.html</code> 中添加：<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="selector-id">#height-wrapper</span> &#123;</span></span><br><span class="line"><span class="undefined">            position: absolute;</span></span><br><span class="line"><span class="undefined">            top: 0;</span></span><br><span class="line"><span class="undefined">            left: 0;</span></span><br><span class="line"><span class="undefined">            right: 0;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">        ;(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> wrapper = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span></span><br><span class="line"><span class="actionscript">            wrapper.id = <span class="string">"height-wrapper"</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">while</span> (<span class="built_in">document</span>.body.firstChild) &#123;</span></span><br><span class="line"><span class="javascript">                wrapper.appendChild(<span class="built_in">document</span>.body.firstChild);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">document</span>.body.appendChild(wrapper);</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">var</span> i = <span class="number">0</span>;</span></span><br><span class="line"><span class="actionscript">            <span class="function"><span class="keyword">function</span> <span class="title">updateHeight</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">document</span>.title = wrapper.clientHeight;</span></span><br><span class="line"><span class="javascript">                <span class="built_in">window</span>.location.hash = ++i;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="javascript">            <span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">                updateHeight();</span></span><br><span class="line"><span class="undefined">            &#125;);</span></span><br><span class="line"><span class="undefined">        &#125;());</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>在 <code>react-native</code> 监听 <code>onNavigationStateChange</code> ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_onNavigationStateChange = <span class="function">(<span class="params">navState</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (navState.title &amp;&amp; (navState.title - <span class="keyword">this</span>.state.webViewHeight &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">            webViewHeight: <span class="built_in">parseInt</span>(navState.title)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="打包后-react-native-找不到资源"><a href="#打包后-react-native-找不到资源" class="headerlink" title="打包后 react-native 找不到资源"></a>打包后 react-native 找不到资源</h3><p>我们的 <code>index.html</code> 引用了其他的 js ， 而 js 中引用了很多图片、音乐、字体 …<br><strong>Android</strong> 和 <strong>Ios</strong> 中需要放在各自的资源目录下，具体是：</p><ul><li><strong>Android</strong> ：<br><code>android/app/src/main/assets/</code> 下，将游戏打包后的文件夹 <code>trivia-game</code> 放到前面的目录下。<br><code>webview</code> 中 <code>source</code> 对应的地址为 <code>file:///android_asset/trivia-game/index.html</code>。<br><code>webview</code> 必须添加 <code>allowUniversalAccessFromFileURLs={ true }</code> ，不然只能读到 js ，而不能读取到 js 引用的其他资源。<br>这是这个属性的介绍： Boolean that sets whether JavaScript running in the context of a file scheme URL should be allowed to access content from any origin. Including accessing content from other file scheme URLs</li><li><strong>Ios</strong> :<br><code>ios/external/</code> 下，若没有 external 目录则先新建一个， 将游戏打包后的文件夹 <code>trivia-game</code> 放到前面的目录下。<br><code>webview</code> 中 <code>source</code> 对应的地址为 <code>./trivia-game/index.html</code>。</li></ul><p>另外，<strong>Android</strong> 下的 <code>Webview</code> 不识别 <code>svg</code> 文件 ，我目前的做法是将文件转为了 <code>base64</code> 格式，不知道有大佬有更好的方案吗？</p><h3 id="ios-下-音乐不自动播放"><a href="#ios-下-音乐不自动播放" class="headerlink" title="ios 下 音乐不自动播放"></a>ios 下 音乐不自动播放</h3><p>添加属性： <code>mediaPlaybackRequiresUserAction={ false }</code> , 原因是 <strong>Ios</strong> 默认需要用户操作才可以播放音乐和视频</p><h3 id="调试工具"><a href="#调试工具" class="headerlink" title="调试工具"></a>调试工具</h3><ul><li><strong>Android</strong> :<br><a href="chrome://inspect/#devices" target="_blank" rel="noopener">chrome://inspect/#devices</a> 是很好用的工具，之前调试 <code>webview</code> 、手机网页 都很好用。但在 <strong>genymotion</strong> 模拟器中，整个调试器的样式都是乱的。查询到这个 <a href="https://stackoverflow.com/questions/47980279/google-chrome-devtools-broken-when-inspecting-android-webview" target="_blank" rel="noopener">答案</a>, 原因是 <strong>Chrome</strong> 去掉了一个 <code>api</code> ，所以我下了旧版的 <strong>Chromium</strong>。前面答案的超链接里有下载地址。</li><li><strong>Ios</strong> : 使用 <strong>Safari</strong> ,具体参考 <a href="https://stackoverflow.com/questions/47991959/how-to-debug-a-webview-in-react-native" target="_blank" rel="noopener">这儿</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;前段时间公司要求写个游戏嵌入到 App 中，我们通过 &lt;code&gt;webview&lt;/code&gt; 链接到 App 中，中间遇到了很多坑，在此记录一下。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; sourceAndroid = &amp;#123; &lt;span class=&quot;attr&quot;&gt;uri&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;file:///android_asset/trivia-game/index.html&#39;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; sourceIOS = &amp;#123; &lt;span class=&quot;attr&quot;&gt;uri&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt;&#39;./trivia-game/index.html&#39;&lt;/span&gt; &amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;source = Platform.OS === &lt;span class=&quot;string&quot;&gt;&#39;ios&#39;&lt;/span&gt; ? sourceIOS : sourceAndroid;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;WebView&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ref=&amp;#123;( webView ) =&amp;gt; &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.webView = webView&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    source=&amp;#123; source &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    originWhitelist=&amp;#123;[&lt;span class=&quot;string&quot;&gt;&quot;file://&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;*&#39;&lt;/span&gt;]&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    style=&amp;#123;&amp;#123;&lt;span class=&quot;attr&quot;&gt;height&lt;/span&gt;: &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.state.webViewHeight&amp;#125;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    javaScriptEnabled = &amp;#123; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    scrollEnabled = &amp;#123; &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    domStorageEnabled = &amp;#123; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    scalesPageToFit = &amp;#123; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    startInLoadingState = &amp;#123; &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt; &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    renderLoading = &amp;#123; () =&amp;gt; &lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;ActivityIndicator&lt;/span&gt; /&amp;gt;&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;    onLoadEnd=&amp;#123; this._onLoadEnd &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;    onMessage=&amp;#123; this._onMessage &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;    onNavigationStateChange=&amp;#123; this._onNavigationStateChange &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;    allowUniversalAccessFromFileURLs=&amp;#123; true &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;    mediaPlaybackRequiresUserAction=&amp;#123; false &amp;#125;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;xml&quot;&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;官方介绍： &lt;a href=&quot;https://reactnative.cn/docs/webview/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;webview&lt;/a&gt;，其中像 &lt;code&gt;javaScriptEnabled&lt;/code&gt; 这些属性是我们常用的，还有一些不常用但很能填坑的属性下面介绍下&lt;/p&gt;&lt;h3 id=&quot;webview-与-react-native-通信&quot;&gt;&lt;a href=&quot;#webview-与-react-native-通信&quot; class=&quot;headerlink&quot; title=&quot;webview 与 react-native 通信&quot;&gt;&lt;/a&gt;webview 与 react-native 通信&lt;/h3&gt;&lt;p&gt;目前只能传递字符串&lt;/p&gt;&lt;h4 id=&quot;webview-给-react-native-发消息：&quot;&gt;&lt;a href=&quot;#webview-给-react-native-发消息：&quot; class=&quot;headerlink&quot; title=&quot;webview 给 react-native 发消息：&quot;&gt;&lt;/a&gt;&lt;code&gt;webview&lt;/code&gt; 给 &lt;code&gt;react-native&lt;/code&gt; 发消息：&lt;/h4&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;window&lt;/span&gt;.postMessage(&lt;span class=&quot;string&quot;&gt;&#39;str&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;code&gt;react-native&lt;/code&gt; 通过 &lt;code&gt;onMessage&lt;/code&gt; 接受消息：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_onMessage = &lt;span class=&quot;function&quot;&gt;(&lt;span class=&quot;params&quot;&gt;e&lt;/span&gt;) =&amp;gt;&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log( &lt;span class=&quot;string&quot;&gt;&quot;On Message&quot;&lt;/span&gt;, e.nativeEvent.data );&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h4 id=&quot;react-native-给-webview-发消息：&quot;&gt;&lt;a href=&quot;#react-native-给-webview-发消息：&quot; class=&quot;headerlink&quot; title=&quot;react-native 给 webview 发消息：&quot;&gt;&lt;/a&gt;&lt;code&gt;react-native&lt;/code&gt; 给 &lt;code&gt;webview&lt;/code&gt; 发消息：&lt;/h4&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.webView.postMessage(&lt;span class=&quot;string&quot;&gt;&#39;str&#39;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;code&gt;webview&lt;/code&gt; 接受消息：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;document&lt;/span&gt;.addEventListener( &lt;span class=&quot;string&quot;&gt;&#39;message&#39;&lt;/span&gt;, event =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;console&lt;/span&gt;.log(event.data)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;, &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jintang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="react-native" scheme="https://jintang.github.io/tags/react-native/"/>
    
  </entry>
  
  <entry>
    <title>算法与数据结构</title>
    <link href="https://jintang.github.io/2018/11/11/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
    <id>https://jintang.github.io/2018/11/11/算法和数据结构学习/</id>
    <published>2018-11-11T13:33:47.000Z</published>
    <updated>2019-07-10T07:43:05.898Z</updated>
    
    <content type="html"><![CDATA[<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h2 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h2><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><ul><li>双层循环(i 从 0 到 length - 1, j 从 i + 1 到 length - 1)</li><li>比较 list[i] 与 list[j] 大小，如果 list[j] &lt; list[i] ，则交换位置</li></ul><p>时间复杂度： $O(N^2)$</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><ul><li>等分目标，直到等分的结果长度为1（时间复杂度 $O(log_2 N)$）</li><li>开始循环，每次 + 2 ，单词循环中对比相邻的两项进行排列，合并之后得到长度为2的单元</li><li>同上次循环，合并得到长度为4的单元</li><li>…</li><li>直到最后，完成合并，得到正确排序数组</li></ul><p>时间复杂度： $O(N log_2 N)$</p><h3 id="图搜索算法：地图常用，比如获取从一个地方到另外一个地方最近的路线"><a href="#图搜索算法：地图常用，比如获取从一个地方到另外一个地方最近的路线" class="headerlink" title="图搜索算法：地图常用，比如获取从一个地方到另外一个地方最近的路线"></a>图搜索算法：地图常用，比如获取从一个地方到另外一个地方最近的路线</h3><p>最普通的 Dijkstra 算法： O(N^2)<br>优化后： O(N * logN)</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数组，在内存上顺序存储。字符串是一种在内存上尾部指针指向 “null” 的数组（即在内存上最后一位是二进制0）。因为是顺序存储，所以很难插入修改。数组中的节点可以一个结构体，这样便可以方便修改。下面是几种常见的结构体数组：</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>每个元素叫做 Node， 存储了一个变量和一个指针（在内存上占用了两个位置），这个指针指向了下一个节点。通过新增一个节点，修改指针的指向可以方便的插入。</p><p>链表有两个比较出名的个例：队列、栈。他们的区别是先进先出与后进先出，专有名词有：出队、进队、出栈、进栈</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>它的节点存储了一个变量和两个指针（在内存上占用了三个位置），分别是左指针和右指针。</p><p>专有名词有： 根节点、母节点、子节点、叶节点（没有子节点的节点）</p><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>它的节点存储了一个变量和多个指针</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;算法&quot;&gt;&lt;a href=&quot;#算法&quot; class=&quot;headerlink&quot; title=&quot;算法&quot;&gt;&lt;/a&gt;算法&lt;/h2&gt;&lt;h2 id=&quot;排序算法&quot;&gt;&lt;a href=&quot;#排序算法&quot; class=&quot;headerlink&quot; title=&quot;排序算法&quot;&gt;&lt;/a&gt;排序算法&lt;/h
    
    </summary>
    
      <category term="算法" scheme="https://jintang.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://jintang.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="https://jintang.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>开发部署以太坊DAPP</title>
    <link href="https://jintang.github.io/2018/10/26/%E5%BC%80%E5%8F%91%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%A4%AA%E5%9D%8ADAPP/"/>
    <id>https://jintang.github.io/2018/10/26/开发部署以太坊DAPP/</id>
    <published>2018-10-26T06:35:24.000Z</published>
    <updated>2018-11-08T06:45:36.051Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考链接： <a href="https://learnblockchain.cn/2018/04/15/web3-html/" target="_blank" rel="noopener">Web3与智能合约交互实战</a></p></blockquote><p><strong>DApp</strong> 是 <strong>Decentralized Application</strong> 的简称，及去中心化应用。DAPP 由客户端和合约端配合实现。<br>我们使用 <a href="https://solidity-cn.readthedocs.io/zh/develop/solidity-in-depth.html" target="_blank" rel="noopener">Solidity</a> 语言编写完合约后，之前我们使用了 <code>geth</code> 与之交互， 而这种命令行的方式太过繁琐，所以我们这儿用到了 <code>Web3.js</code>。</p><p><strong>Web3.js</strong> 是以太坊官方的Javascript API，可以帮助智能合约开发者使用HTTP或者IPC与本地的或者远程的以太坊节点交互。实际上就是一个库的集合，主要包括下面几个库：</p><ul><li>web3-eth 用来与以太坊区块链和智能合约交互</li><li>web3-shh 用来控制whisper协议与p2p通信以及广播</li><li>web3-bzz 用来与swarm协议交互</li><li>web3-utils 包含了一些Dapp开发有用的功能</li></ul><p>这儿我们主要用到了 <code>web3-eth</code>。下面开始</p><h2 id="使用-ganache-生成一条私有链"><a href="#使用-ganache-生成一条私有链" class="headerlink" title="使用 ganache 生成一条私有链"></a>使用 ganache 生成一条私有链</h2><p>ganache 是一个可以一键搭建以太坊区块链测试环境的工具。 启动之后默认会生成 10 个账号， 我们的私有链默认运行在 <a href="http://127.0.0.1:7545" target="_blank" rel="noopener">http://127.0.0.1:7545</a>上。<br><a id="more"></a></p><h2 id="编写合约"><a href="#编写合约" class="headerlink" title="编写合约"></a>编写合约</h2><p>我们使用在线的 <a href="http://remix.ethereum.org/#optimize=true&amp;version=soljson-v0.4.25+commit.59dbf8f1.js" target="_blank" rel="noopener">Remix IDE</a> 来编写代码。</p><p><em>InfoContract.sol</em>:<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.21</span>;</span><br><span class="line"></span><br><span class="line">contract InfoContract &#123;</span><br><span class="line">    </span><br><span class="line">  string fName;</span><br><span class="line">  uint age;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setInfo</span>(<span class="params">string _fName, uint _age</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">    fName = _fName;</span><br><span class="line">    age = _age;</span><br><span class="line">    emit Instructor(_fName, _age);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getInfo</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">constant</span> <span class="title">returns</span> (<span class="params">string, uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (fName, age);</span><br><span class="line">  &#125;   </span><br><span class="line">   </span><br><span class="line">  event Instructor(</span><br><span class="line">    string name,</span><br><span class="line">    uint age</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>代码很简单，就是简单的给name和age变量赋值与读取。 并在赋值的时候触发了一个 Instructor 事件。</p><p><a href="https://solidity-cn.readthedocs.io/zh/develop/solidity-in-depth.html" target="_blank" rel="noopener">Solidity</a> 里有很多高级的用法，你还可以给事件添加过滤器…这儿只用了最简单的。</p><h2 id="编译与部署合约"><a href="#编译与部署合约" class="headerlink" title="编译与部署合约"></a>编译与部署合约</h2><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>选择 <code>Start to compile</code>， 编译成功会出现绿色的合约名称，失败则提示相应的错误信息。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>切换到 run 的 tab 下，将 Environment 切换成 <code>Web3 Provider</code>，并输入我们的测试链的地址 <a href="http://127.0.0.1:7545" target="_blank" rel="noopener">http://127.0.0.1:7545</a>, Environment 选项的含义为：</p><ul><li><strong>Javascript VM</strong> ：简单的Javascript虚拟机环境，纯粹练习智能合约编写的时候可以选择</li><li><strong>Injected Web3</strong> ：连接到嵌入到页面的Web3，比如连接到MetaMask</li><li><strong>Web3 Provider</strong> ：连接到自定义的节点，如私有的测试网络。</li></ul><p>然后选择 <code>Deploy</code> ,成功后会在 <code>Deployed Contracts</code> 下显示部署成功的合约。并且在 <strong>Remix IDE</strong> 终端下显示合约创建的交易信息。同时，在 ganache 中也生成了对应的区块和交易信息。</p><h2 id="编写客户端"><a href="#编写客户端" class="headerlink" title="编写客户端"></a>编写客户端</h2><p>为了与合约交互，我们使用 <code>web3.js</code> 。</p><h3 id="新建项目并安装-web3-js"><a href="#新建项目并安装-web3-js" class="headerlink" title="新建项目并安装 web3.js"></a>新建项目并安装 web3.js</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir simple-DAPP &amp;&amp; <span class="built_in">cd</span> simple-DAPP</span><br><span class="line">npm init</span><br><span class="line">npm install web3 -D</span><br></pre></td></tr></table></figure><h3 id="构建页面与交互逻辑"><a href="#构建页面与交互逻辑" class="headerlink" title="构建页面与交互逻辑"></a>构建页面与交互逻辑</h3><p>页面、样式省略，下面说下 js 中需要注意的部分。</p><ol><li>创建 web3 :<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    web3 = <span class="keyword">new</span> Web3(web3.currentProvider);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// set the provider you want from Web3.providers</span></span><br><span class="line">    web3 = <span class="keyword">new</span> Web3(<span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">"http://localhost:7545"</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>上面是 web3 官方的创建方法，本例中的 web3 是通过 <a href="http://localhost:7545" target="_blank" rel="noopener">http://localhost:7545</a> 创建的。而如果你使用类似 <code>MetaMask</code> （一个 Chrome 上的插件，迷你型以太坊钱包）这样的软件，provider 就会被自动植入。</p><ol><li><p>绑定账号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web3.eth.defaultAccount = web3.eth.accounts[<span class="number">0</span>]; <span class="comment">// ganache生成的10个账号中随便取一个作为默认账号</span></span><br></pre></td></tr></table></figure></li><li><p>通过 ABI 创建一个Solidity的合约对象，用来在某个地址上初始化合约<br><code>Application Binary Interface(ABI)</code> 是从区块链外部与合约进行交互以及合约与合约间进行交互的一种标准方式。事实上， <code>Solidity</code> 里的合约的含义就是它的 函数 和 数据（它的 状态 ），它们位于以太坊区块链的一个特定地址上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// abi 通过 Remix IDE 的 compile 面板下 ABI 按钮复制</span></span><br><span class="line"><span class="keyword">let</span> infoContract = web3.eth.contract(abi);</span><br></pre></td></tr></table></figure></li></ol><p>这是此合约生成的 ABI :<br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"constant"</span>: <span class="literal">false</span>,</span><br><span class="line">		<span class="attr">"inputs"</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">"name"</span>: <span class="string">"_fName"</span>,</span><br><span class="line">				<span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">"name"</span>: <span class="string">"_age"</span>,</span><br><span class="line">				<span class="attr">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">			&#125;</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">"name"</span>: <span class="string">"setInfo"</span>,</span><br><span class="line">		<span class="attr">"outputs"</span>: [],</span><br><span class="line">		<span class="attr">"payable"</span>: <span class="literal">false</span>,</span><br><span class="line">		<span class="attr">"stateMutability"</span>: <span class="string">"nonpayable"</span>,</span><br><span class="line">		<span class="attr">"type"</span>: <span class="string">"function"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"anonymous"</span>: <span class="literal">false</span>,</span><br><span class="line">		<span class="attr">"inputs"</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">"indexed"</span>: <span class="literal">false</span>,</span><br><span class="line">				<span class="attr">"name"</span>: <span class="string">"name"</span>,</span><br><span class="line">				<span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">"indexed"</span>: <span class="literal">false</span>,</span><br><span class="line">				<span class="attr">"name"</span>: <span class="string">"age"</span>,</span><br><span class="line">				<span class="attr">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">			&#125;</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">"name"</span>: <span class="string">"Instructor"</span>,</span><br><span class="line">		<span class="attr">"type"</span>: <span class="string">"event"</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="attr">"constant"</span>: <span class="literal">true</span>,</span><br><span class="line">		<span class="attr">"inputs"</span>: [],</span><br><span class="line">		<span class="attr">"name"</span>: <span class="string">"getInfo"</span>,</span><br><span class="line">		<span class="attr">"outputs"</span>: [</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">"name"</span>: <span class="string">""</span>,</span><br><span class="line">				<span class="attr">"type"</span>: <span class="string">"string"</span></span><br><span class="line">			&#125;,</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="attr">"name"</span>: <span class="string">""</span>,</span><br><span class="line">				<span class="attr">"type"</span>: <span class="string">"uint256"</span></span><br><span class="line">			&#125;</span><br><span class="line">		],</span><br><span class="line">		<span class="attr">"payable"</span>: <span class="literal">false</span>,</span><br><span class="line">		<span class="attr">"stateMutability"</span>: <span class="string">"view"</span>,</span><br><span class="line">		<span class="attr">"type"</span>: <span class="string">"function"</span></span><br><span class="line">	&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><p>可以看到这是对合约里函数的描述。此合约里没有状态，</p><ol><li>通过合约地址获取合约实例<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合约地址 在 Remix IDE 的 run 面板 —— Deployed Contracts 下</span></span><br><span class="line"><span class="keyword">let</span> info = infoContract.at(<span class="string">'合约地址'</span>);</span><br></pre></td></tr></table></figure></li></ol><p>然后就可以使用合约里的函数和事件了，详细查看 <a href="https://github.com/jintangWang/simple-DAPP/blob/master/main.js" target="_blank" rel="noopener">demo</a></p><p><strong>至此：</strong> <code>DAPP</code> 的 客户端 编写完成。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>我通过 webpack 启动了客户端，每次点击 <code>Update Info</code> 按钮都会生成一条交易。<br><img src="https://tang-blog-1257996120.cos-website.ap-chengdu.myqcloud.com/dapp_transcation.png" alt="dapp_transcation"><br>交易可以看作是从一个帐户发送到另一个帐户的消息。它能包含一个二进制数据（合约负载）和以太币。如果目标账户含有代码，此代码会被执行，并以 payload 作为入参。如果目标账户是零账户（账户地址为 0 )，此交易将创建一个 新合约 。 如前文所述，合约的地址不是零地址，而是通过合约创建者的地址和从该地址发出过的交易数量计算得到的（所谓的“nonce”）</p><p><em>说明：</em> 一经创建，每笔交易都收取一定数量的 gas 。无论执行到什么位置，一旦 gas 被耗尽（比如降为负值），将会触发一个 <code>out-of-gas</code> 异常。当前调用帧（call frame）所做的所有状态修改都将被回滚。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可以用下图来描述 <code>DAPP</code> 的原理。<br><img src="https://tang-blog-1257996120.cos-website.ap-chengdu.myqcloud.com/DAPP_theory.png" alt="DAPP_theory"><br>我们的 demo 完成了 客户端 和 合约端。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;参考链接： &lt;a href=&quot;https://learnblockchain.cn/2018/04/15/web3-html/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Web3与智能合约交互实战&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;strong&gt;DApp&lt;/strong&gt; 是 &lt;strong&gt;Decentralized Application&lt;/strong&gt; 的简称，及去中心化应用。DAPP 由客户端和合约端配合实现。&lt;br&gt;我们使用 &lt;a href=&quot;https://solidity-cn.readthedocs.io/zh/develop/solidity-in-depth.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Solidity&lt;/a&gt; 语言编写完合约后，之前我们使用了 &lt;code&gt;geth&lt;/code&gt; 与之交互， 而这种命令行的方式太过繁琐，所以我们这儿用到了 &lt;code&gt;Web3.js&lt;/code&gt;。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;Web3.js&lt;/strong&gt; 是以太坊官方的Javascript API，可以帮助智能合约开发者使用HTTP或者IPC与本地的或者远程的以太坊节点交互。实际上就是一个库的集合，主要包括下面几个库：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;web3-eth 用来与以太坊区块链和智能合约交互&lt;/li&gt;&lt;li&gt;web3-shh 用来控制whisper协议与p2p通信以及广播&lt;/li&gt;&lt;li&gt;web3-bzz 用来与swarm协议交互&lt;/li&gt;&lt;li&gt;web3-utils 包含了一些Dapp开发有用的功能&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这儿我们主要用到了 &lt;code&gt;web3-eth&lt;/code&gt;。下面开始&lt;/p&gt;&lt;h2 id=&quot;使用-ganache-生成一条私有链&quot;&gt;&lt;a href=&quot;#使用-ganache-生成一条私有链&quot; class=&quot;headerlink&quot; title=&quot;使用 ganache 生成一条私有链&quot;&gt;&lt;/a&gt;使用 ganache 生成一条私有链&lt;/h2&gt;&lt;p&gt;ganache 是一个可以一键搭建以太坊区块链测试环境的工具。 启动之后默认会生成 10 个账号， 我们的私有链默认运行在 &lt;a href=&quot;http://127.0.0.1:7545&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://127.0.0.1:7545&lt;/a&gt;上。&lt;br&gt;
    
    </summary>
    
      <category term="区块链" scheme="https://jintang.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="DAPP" scheme="https://jintang.github.io/tags/DAPP/"/>
    
  </entry>
  
  <entry>
    <title>用truffle框架开发部署以太坊DAPP</title>
    <link href="https://jintang.github.io/2018/10/11/%E7%94%A8truffle%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%A4%AA%E5%9D%8ADAPP/"/>
    <id>https://jintang.github.io/2018/10/11/用truffle框架开发部署以太坊DAPP/</id>
    <published>2018-10-11T13:33:11.000Z</published>
    <updated>2018-10-26T10:05:19.173Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>参考链接：<a href="https://truffleframework.com/tutorials/pet-shop" target="_blank" rel="noopener">ETHEREUM PET SHOP – YOUR FIRST DAPP</a></p></blockquote><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><ul><li><p><a href="https://truffleframework.com" target="_blank" rel="noopener">Truffle</a>: 以太坊Solidity编程语言开发框架。安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g truffle</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://truffleframework.com/ganache" target="_blank" rel="noopener">Ganache</a>: 前身testRPC，可以启动一个个人的以太坊私有链用作测试、执行命令、检测区块执行状态。点击前面的连接下载客户端即可。</p></li></ul><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><ol><li><p>建立项目目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir pet-shop &amp;&amp; <span class="built_in">cd</span> pet-shop</span><br></pre></td></tr></table></figure></li><li><p>使用 <code>truffle unbox</code> 创建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">truffle unbox pet-shop</span><br><span class="line"><span class="comment"># Downloading...</span></span><br><span class="line"><span class="comment"># Unpacking...</span></span><br><span class="line"><span class="comment"># Setting up...</span></span><br><span class="line"><span class="comment"># Unbox successful. Sweet!</span></span><br></pre></td></tr></table></figure></li></ol><p><em>注:</em> 我们可以使用 <code>truffle unbox &lt;box-name&gt;</code> 下载任意的 Truffle Boxes。 在 <a href="https://truffleframework.com/boxes" target="_blank" rel="noopener">truffle box 仓库</a> 可以看到很多 Box , 上面我们下载的是 <a href="https://truffleframework.com/boxes/pet-shop" target="_blank" rel="noopener">pet-shop box</a></p><p>下载完成后,可以看到下面这些重要的目录和文件：</p><ul><li>contracts/ 智能合约的文件夹，所有的智能合约文件都放置在这里，里面包含一个重要的合约Migrations.sol</li><li>migrations/ 用来处理部署（迁移）智能合约 ，迁移是一个额外特别的合约用来保存合约的变化。</li><li>test/ 智能合约测试用例文件夹</li><li>truffle.js 配置文件</li></ul><a id="more"></a><h2 id="编写智能合约"><a href="#编写智能合约" class="headerlink" title="编写智能合约"></a>编写智能合约</h2><p>在contracts目录下，添加合约文件Adoption.sol</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.17</span>;</span><br><span class="line"></span><br><span class="line">contract Adoption &#123;</span><br><span class="line"></span><br><span class="line">  address[<span class="number">16</span>] public adopters;  <span class="comment">// 保存领养者的地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 领养宠物</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">adopt</span>(<span class="params">uint petId</span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">require</span>(petId &gt;= <span class="number">0</span> &amp;&amp; petId &lt;= <span class="number">15</span>);  <span class="comment">// 确保id在数组长度内</span></span><br><span class="line"></span><br><span class="line">    adopters[petId] = msg.sender;        <span class="comment">// msg.sender 表示调用此方法的人或者智能合约</span></span><br><span class="line">    <span class="keyword">return</span> petId;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回领养者</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getAdopters</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">address[<span class="number">16</span>]</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> adopters;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编译部署智能合约"><a href="#编译部署智能合约" class="headerlink" title="编译部署智能合约"></a>编译部署智能合约</h2><p>在项目根目录下：</p><p><strong>编译：</strong><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">truffle compile</span><br><span class="line"><span class="comment"># Compiling ./contracts/Adoption.sol...</span></span><br><span class="line"><span class="comment"># Writing artifacts to ./build/contracts</span></span><br></pre></td></tr></table></figure><p></p><p><strong>部署</strong>:</p><p>在 migrations 文件夹下已经有一个 <code>1_initial_migration.js</code> 部署脚本，用来部署 <code>Migrations.sol</code> 合约。</p><p><code>Migrations.sol</code> 用来确保不会部署相同的合约。</p><p>我们来创建一个自己的部署脚本 <code>2_deploy_contracts.js</code><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Adoption = artifacts.require(<span class="string">"Adoption"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">deployer</span>) </span>&#123;</span><br><span class="line">  deployer.deploy(Adoption);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p></p><p>在执行部署之前，需要确保有一个区块链运行, 可以使用 Ganache 来开启一个私链。 Ganache 启动之后默认会在 7545 端口上运行一个开发链，然后执行下面的命令将合约部署到链上：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">truffle  migrate</span><br><span class="line"><span class="comment"># Using network 'development'.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Running migration: 1_initial_migration.js</span></span><br><span class="line"><span class="comment">#  Deploying Migrations...</span></span><br><span class="line"><span class="comment">#  ... 0xcc1a5aea7c0a8257ba3ae366b83af2d257d73a5772e84393b0576065bf24aedf</span></span><br><span class="line"><span class="comment">#  Migrations: 0x8cdaf0cd259887258bc13a92c0a6da92698644c0</span></span><br><span class="line"><span class="comment"># Saving successful migration to network...</span></span><br><span class="line"><span class="comment">#  ... 0xd7bc86d31bee32fa3988f1c1eabce403a1b5d570340a3a9cdba53a472ee8c956</span></span><br><span class="line"><span class="comment"># Saving artifacts...</span></span><br><span class="line"><span class="comment"># Running migration: 2_deploy_contracts.js</span></span><br><span class="line"><span class="comment">#  Deploying Adoption...</span></span><br><span class="line"><span class="comment">#  ... 0x43b6a6888c90c38568d4f9ea494b9e2a22f55e506a8197938fb1bb6e5eaa5d34</span></span><br><span class="line"><span class="comment">#  Adoption: 0x345ca3e014aaf5dca488057592ee47305d9b3e10</span></span><br><span class="line"><span class="comment"># Saving successful migration to network...</span></span><br><span class="line"><span class="comment">#  ... 0xf36163615f41ef7ed8f4a8f192149a0bf633fe1a2398ce001bf44c43dc7bdda0</span></span><br><span class="line"><span class="comment"># Saving artifacts...</span></span><br></pre></td></tr></table></figure><p>在打开的Ganache里可以看到区块链状态的变化，现在产生了4个区块。并且发现账号下刚开始的 100 个 <code>eth</code> 少了 零点几 个</p><p>这时说明已经智能合约已经部署好了。</p><h2 id="创建用户接口和智能合约交互"><a href="#创建用户接口和智能合约交互" class="headerlink" title="创建用户接口和智能合约交互"></a>创建用户接口和智能合约交互</h2><p>我们已经编写和部署及测试好了我们的合约，接下我们为合约编写UI，让合约真正可以用起来。</p><p>在Truffle Box <code>pet-shop</code>里，已经包含了应用的前端代码，代码在 <code>src/</code> 文件夹下。</p><p>修改 <code>src/js/app.js</code> 部分代码：</p><h3 id="初始化-web3-实例，修改-initWeb3-为："><a href="#初始化-web3-实例，修改-initWeb3-为：" class="headerlink" title="初始化 web3 实例，修改 initWeb3() 为："></a>初始化 <a href="https://github.com/ethereum/web3.js" target="_blank" rel="noopener">web3</a> 实例，修改 <code>initWeb3()</code> 为：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">initWeb3: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Is there an injected web3 instance?</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> web3 !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        App.web3Provider = web3.currentProvider;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If no injected web3 instance is detected, fall back to Ganache</span></span><br><span class="line">        App.web3Provider = <span class="keyword">new</span> Web3.providers.HttpProvider(<span class="string">'http://localhost:7545'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    web3 = <span class="keyword">new</span> Web3(App.web3Provider);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> App.initContract();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例化合约，修改-initContract-为："><a href="#实例化合约，修改-initContract-为：" class="headerlink" title="实例化合约，修改 initContract() 为："></a>实例化合约，修改 <code>initContract()</code> 为：</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">initContract: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $.getJSON(<span class="string">'Adoption.json'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">        <span class="comment">// Get the necessary contract artifact file and instantiate it with truffle-contract</span></span><br><span class="line">        <span class="keyword">var</span> AdoptionArtifact = data;</span><br><span class="line">        <span class="comment">// 通过 truffle-contract.js 创建与我们交互的合约实例</span></span><br><span class="line">        App.contracts.Adoption = TruffleContract(AdoptionArtifact);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Set the provider for our contract</span></span><br><span class="line">        App.contracts.Adoption.setProvider(App.web3Provider);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// Use our contract to retrieve and mark the adopted pets</span></span><br><span class="line">        <span class="keyword">return</span> App.markAdopted();</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> App.bindEvents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>说明：</em> Artifacts 是关于合约的信息。比如部署地址和 ABI(Application Binary Interface)。ABI 是一个 js 对象，定义了如何与智能合约交互</p><h3 id="处理领养"><a href="#处理领养" class="headerlink" title="处理领养"></a>处理领养</h3><p>修改 <code>markAdopted()</code> 为：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">markAdopted: <span class="function"><span class="keyword">function</span>(<span class="params">adopters, account</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> adoptionInstance;</span><br><span class="line"></span><br><span class="line">    App.contracts.Adoption.deployed().then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">        adoptionInstance = instance;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用合约的getAdopters(), 用call读取链上的信息不用消耗gas</span></span><br><span class="line">        <span class="keyword">return</span> adoptionInstance.getAdopters.call();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">adopters</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; adopters.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果宠物已经被收养了，不允许重复收养</span></span><br><span class="line">            <span class="keyword">if</span> (adopters[i] !== <span class="string">'0x0000000000000000000000000000000000000000'</span>) &#123;</span><br><span class="line">                $(<span class="string">'.panel-pet'</span>).eq(i).find(<span class="string">'button'</span>).text(<span class="string">'Success'</span>).attr(<span class="string">'disabled'</span>, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err.message);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>修改 <code>handleAdopt()</code> 为：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">handleAdopt: <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> petId = <span class="built_in">parseInt</span>($(event.target).data(<span class="string">'id'</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> adoptionInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取用户账号</span></span><br><span class="line">    web3.eth.getAccounts(<span class="function"><span class="keyword">function</span>(<span class="params">error, accounts</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(error);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">var</span> account = accounts[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">        App.contracts.Adoption.deployed().then(<span class="function"><span class="keyword">function</span>(<span class="params">instance</span>) </span>&#123;</span><br><span class="line">            adoptionInstance = instance;</span><br><span class="line">        </span><br><span class="line">            <span class="comment">// 调用 Adoption.sol 里的 adopt 方法发起领养宠物交易</span></span><br><span class="line">            <span class="keyword">return</span> adoptionInstance.adopt(petId, &#123;<span class="attr">from</span>: account&#125;);</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">result</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> App.markAdopted();</span><br><span class="line">        &#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(err.message);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><em>注：</em> 收养宠物是一个交易而不是 call ,交易需要支付 <code>gas</code> 。 <code>gas</code> 是智能合约计算和存储数据需要付出的费用，和 <code>eth</code> 之间有一个换算方法。</p><h2 id="在浏览器中运行"><a href="#在浏览器中运行" class="headerlink" title="在浏览器中运行"></a>在浏览器中运行</h2><h3 id="安装-MetaMask"><a href="#安装-MetaMask" class="headerlink" title="安装 MetaMask"></a>安装 MetaMask</h3><p>MetaMask 是一款浏览器插件形式的以太坊轻客户端，允许你不下载整个以太坊节点而在浏览器中运行以太坊的 DAPP</p><h3 id="配置钱包"><a href="#配置钱包" class="headerlink" title="配置钱包"></a>配置钱包</h3><p>我们通过还原一个Ganache为我们创建好的钱包，作为我们的开发测试钱包。<br>打开 MetaMask ，选择 <strong>Import using account seed phrase</strong>, 输入Ganache显示的助记词。<br>我的是：<br></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">heavy</span> <span class="keyword">best </span>inner hobby chef <span class="keyword">bread </span><span class="meta">entry</span> oyster dose float napkin media</span><br></pre></td></tr></table></figure><p></p><p>配置密码之后即可看到账号，里面有 100 个初始 <code>eth</code></p><h3 id="连接开发区块链网络"><a href="#连接开发区块链网络" class="headerlink" title="连接开发区块链网络"></a>连接开发区块链网络</h3><p>在 MetaMask 的 Networks 里选择 <strong>Custom RPC</strong> , 添加一个网络：<a href="http://127.0.0.1:7545" target="_blank" rel="noopener">http://127.0.0.1:7545</a> 即可。</p><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>Truffle Box <code>pet-shop</code> 里人家提供了一个服务: lite-server。</p><p><code>bs-config.json</code> 指示了lite-server的工作目录。<br></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"server"</span>: &#123;</span><br><span class="line">    <span class="attr">"baseDir"</span>: [<span class="string">"./src"</span>, <span class="string">"./build/contracts"</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>./src 是网站文件目录</p><p>./build/contracts 是合约输出目录</p><p>在 <code>package.json</code> 中已配置了：<br></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">"scripts": &#123;</span><br><span class="line">  "dev": "lite-server",</span><br><span class="line">  "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们只需要运行：<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev</span><br></pre></td></tr></table></figure><p></p><p>然后就可以在 <a href="http://localhost:3000/" target="_blank" rel="noopener">http://localhost:3000/</a> 访问到此 DAPP 了。如果你收养了宠物，也会在 MetaMask 与 Ganache 中显示你账号的交易信息</p><p><strong>Over</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;参考链接：&lt;a href=&quot;https://truffleframework.com/tutorials/pet-shop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ETHEREUM PET SHOP – YOUR FIRST DAPP&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;开发环境&quot;&gt;&lt;a href=&quot;#开发环境&quot; class=&quot;headerlink&quot; title=&quot;开发环境&quot;&gt;&lt;/a&gt;开发环境&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://truffleframework.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Truffle&lt;/a&gt;: 以太坊Solidity编程语言开发框架。安装：&lt;/p&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;bash&quot;&gt; npm install -g truffle&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;a href=&quot;https://truffleframework.com/ganache&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Ganache&lt;/a&gt;: 前身testRPC，可以启动一个个人的以太坊私有链用作测试、执行命令、检测区块执行状态。点击前面的连接下载客户端即可。&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;初始化项目&quot;&gt;&lt;a href=&quot;#初始化项目&quot; class=&quot;headerlink&quot; title=&quot;初始化项目&quot;&gt;&lt;/a&gt;初始化项目&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;p&gt;建立项目目录&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;mkdir pet-shop &amp;amp;&amp;amp; &lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; pet-shop&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;使用 &lt;code&gt;truffle unbox&lt;/code&gt; 创建项目&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;truffle unbox pet-shop&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Downloading...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Unpacking...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Setting up...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# Unbox successful. Sweet!&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;&lt;em&gt;注:&lt;/em&gt; 我们可以使用 &lt;code&gt;truffle unbox &amp;lt;box-name&amp;gt;&lt;/code&gt; 下载任意的 Truffle Boxes。 在 &lt;a href=&quot;https://truffleframework.com/boxes&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;truffle box 仓库&lt;/a&gt; 可以看到很多 Box , 上面我们下载的是 &lt;a href=&quot;https://truffleframework.com/boxes/pet-shop&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;pet-shop box&lt;/a&gt;&lt;/p&gt;&lt;p&gt;下载完成后,可以看到下面这些重要的目录和文件：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;contracts/ 智能合约的文件夹，所有的智能合约文件都放置在这里，里面包含一个重要的合约Migrations.sol&lt;/li&gt;&lt;li&gt;migrations/ 用来处理部署（迁移）智能合约 ，迁移是一个额外特别的合约用来保存合约的变化。&lt;/li&gt;&lt;li&gt;test/ 智能合约测试用例文件夹&lt;/li&gt;&lt;li&gt;truffle.js 配置文件&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="区块链" scheme="https://jintang.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="DAPP" scheme="https://jintang.github.io/tags/DAPP/"/>
    
  </entry>
  
  <entry>
    <title>react vs vue</title>
    <link href="https://jintang.github.io/2018/09/05/react-vs-vue/"/>
    <id>https://jintang.github.io/2018/09/05/react-vs-vue/</id>
    <published>2018-09-05T08:14:03.000Z</published>
    <updated>2019-07-10T08:00:55.435Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>先接触了 <code>vue</code> ，感觉 <code>vue</code> 特别方便，优雅的想让你上瘾。后面接触了 <code>react native</code> 开发 App， 过来过去都感觉不适应，再慢慢用过一段日子之后，感觉 <code>react</code> 也有自己鲜明的特点，在使用 <code>react</code> 的时候，总想着和 <code>vue</code> 对比一下。由于自己使用 <code>react</code> 主要是在用 <code>react native</code>， 所以有些东西可能了解不深，望海涵。通过对比借此加深下理解的。</p></blockquote><table><thead><tr><th>Vue</th><th style="text-align:center">React</th><th style="text-align:center">补充说明</th></tr></thead><tbody><tr><td>Computed、watch</td><td style="text-align:center">React 不监听数据变化</td><td style="text-align:center">React可以使用 <code>mobx</code> 库来实现这些功能，在 vue 官方描述的 <a href="https://cn.vuejs.org/v2/guide/comparison.html#MobX" target="_blank" rel="noopener">对比其他框架</a> 里面有这样一句话： 在有限程度上，React + Mobx 也可以被认为是更繁琐的 Vue</td></tr><tr><td>v-model, 这只是通过语法糖定义了一个自定义指令，本质跟 React 一样. 修饰符<code>.async</code> 也是一样</td><td style="text-align:center">React是单向数据流，只能通过事件触发，然后再setState，React没有自定义指令</td><td style="text-align:center">/</td></tr><tr><td>传统 HTML标签渲染 / jsx render渲染</td><td style="text-align:center">jsx</td><td style="text-align:center">/</td></tr><tr><td>Vuex</td><td style="text-align:center">Redux</td><td style="text-align:center">react 有一个中间件react-redux 可以让我们方便的使用 Redux</td></tr><tr><td>EventBus 非父子组件通信</td><td style="text-align:center"><a href="https://github.com/mroderick/PubSubJS" target="_blank" rel="noopener">PubSubJS</a> 或 <a href="http://millermedeiros.github.io/js-signals/" target="_blank" rel="noopener">js-signals</a></td><td style="text-align:center">react-native 中还没用过，没遇到需要的场景</td></tr><tr><td>混入：mixins</td><td style="text-align:center">class组件不可用，在使用 <code>createReactClass</code> 创建 <code>React</code> 组件的时候可用 mixins</td><td style="text-align:center">我们可以要把 mixin 的东西写到单独的 js 文件里，通过 import 实现 mixin，这个本来就是锦上添花，不甚重要</td></tr><tr><td>slot</td><td style="text-align:center">props.chldren</td><td style="text-align:center">自定义组件获取使用时传入的子元素</td></tr><tr><td>自定义指令</td><td style="text-align:center">自己通过事件触发实现类似效果</td><td style="text-align:center">自定义指令可以实现类似于 限制 input 输入格式 等效果</td></tr></tbody></table><p>还有一些是两者非常类似的，只要会了一个，另一个也就会了：</p><ul><li>生命周期方法： 虽然名称不同，但使用一样</li><li>ref ： react 有多种使用 ref 的方法， 具体请看 <a href="https://jintang.github.io/2018/05/11/react-native%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/">另外一篇文章</a></li></ul><a id="more"></a><h2 id="React-补充"><a href="#React-补充" class="headerlink" title="React 补充"></a>React 补充</h2><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>本质上来讲， <code>JSX</code> 只是为 <code>React.createElement(component, props, ...children)</code> 方法提供的语法糖， 所以文件中必须引入 <code>React</code> —— <code>import &#39;React&#39; from &#39;react&#39;</code></p><ul><li><code>JSX</code> 中使用的标签，小写代表内置组件，大写代表自定义组件。如 <code>&lt;div&gt;&lt;/div&gt;</code> 与 <code>&lt;Hello&gt;</code> 分别是内置组件和自定义组件</li><li><code>JSX</code> 可以直接使用的判断运算符： <code>&amp;&amp;</code> 、 <code>? :</code> ；可以直接使用的循环遍历方法： <code>map</code> ，因为 <code>map</code> 会返回一个新数组</li></ul><p><em>注意：</em> 循环渲染时，数组元素中使用的 <code>key</code> 在其兄弟之间应该是独一无二的。然而，它们不需要是全局唯一的。当我们生成两个不同的数组时，我们可以使用相同的键。 另外 <code>key</code> 尽量不要使用 index 或其他随机数，如果数组重排的话 React 的差异比较算法会认为全部需要重新渲染。</p><h3 id="props-children"><a href="#props-children" class="headerlink" title="props.children"></a>props.children</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;FancyBorder color=<span class="string">"blue"</span>&gt;</span><br><span class="line">            &lt;h1 className=<span class="string">"Dialog-title"</span>&gt;</span><br><span class="line">                Welcome</span><br><span class="line">            &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>FancyBorder&gt;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上我们定义了一个 <code>FancyBorder</code> 自定义组件， 那么它内部的 <code>props.children</code> 就是它的子元素，即 <code>&lt;h1&gt;</code> 包裹的那一段。</p><h3 id="构造函数是唯一能够初始化-this-state-的地方。而其他地方更新-state-只能用-setState-updater-callback"><a href="#构造函数是唯一能够初始化-this-state-的地方。而其他地方更新-state-只能用-setState-updater-callback" class="headerlink" title="构造函数是唯一能够初始化 this.state 的地方。而其他地方更新 state 只能用 setState(updater, [callback])"></a>构造函数是唯一能够初始化 this.state 的地方。而其他地方更新 <code>state</code> 只能用 <code>setState(updater, [callback])</code></h3><p><em>注意：</em> <code>setState()</code> 认为是一次请求而不是一次立即执行更新组件的命令。为了更为可观的性能， <code>React</code> 可能会推迟它，稍后会一次性更新这些组件。 <code>React</code> 不会保证在 <code>setState</code> 之后，能够立刻拿到改变的结果。</p><p>第一个参数 updater 如下:</p><ul><li>普通对象，最常见，如： <code>this.setState({name: &#39;小明&#39;})</code></li><li>updater函数，因为 this.state 可能是异步更新的，如果之后的状态依赖于之前的状态，此时就需要这种方式实现。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Wrong */</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/* Correct */</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">    counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure></li></ul><p>第二个参数在 <code>setState</code> 执行完成同时组件被重渲之后执行。通常，对于这类逻辑，我们推荐使用 <code>componentDidUpdate</code></p><h3 id="事件绑定-this-JSX-回调函数中的-this，类的方法默认是不会绑定-this-的"><a href="#事件绑定-this-JSX-回调函数中的-this，类的方法默认是不会绑定-this-的" class="headerlink" title="事件绑定 this : JSX 回调函数中的 this，类的方法默认是不会绑定 this 的"></a>事件绑定 this : <code>JSX</code> 回调函数中的 this，类的方法默认是不会绑定 this 的</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">funciton handleClick1(param, e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleClick2 = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">            <span class="comment">/* 1. 利用 bind, 此时 e 会是参数中的最后一个 */</span></span><br><span class="line">            &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick1.bind(<span class="keyword">this</span>， param)&#125;&gt;方法<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">            /</span>* <span class="number">2.</span> 利用 箭头函数，需将 handleClick 定义为箭头函数格式 *<span class="regexp">/</span></span><br><span class="line"><span class="regexp">            &lt;button onClick=&#123;this.handleClick2&#125;&gt;方法2&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><p><em>注意：</em> 事件回调事件不能通过 <code>reture false</code> 来阻止默认行为，必须得通过 <code>e.preventDefault()</code></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;先接触了 &lt;code&gt;vue&lt;/code&gt; ，感觉 &lt;code&gt;vue&lt;/code&gt; 特别方便，优雅的想让你上瘾。后面接触了 &lt;code&gt;react native&lt;/code&gt; 开发 App， 过来过去都感觉不适应，再慢慢用过一段日子之后，感觉 &lt;code&gt;react&lt;/code&gt; 也有自己鲜明的特点，在使用 &lt;code&gt;react&lt;/code&gt; 的时候，总想着和 &lt;code&gt;vue&lt;/code&gt; 对比一下。由于自己使用 &lt;code&gt;react&lt;/code&gt; 主要是在用 &lt;code&gt;react native&lt;/code&gt;， 所以有些东西可能了解不深，望海涵。通过对比借此加深下理解的。&lt;/p&gt;&lt;/blockquote&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Vue&lt;/th&gt;&lt;th style=&quot;text-align:center&quot;&gt;React&lt;/th&gt;&lt;th style=&quot;text-align:center&quot;&gt;补充说明&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;Computed、watch&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;React 不监听数据变化&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;React可以使用 &lt;code&gt;mobx&lt;/code&gt; 库来实现这些功能，在 vue 官方描述的 &lt;a href=&quot;https://cn.vuejs.org/v2/guide/comparison.html#MobX&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;对比其他框架&lt;/a&gt; 里面有这样一句话： 在有限程度上，React + Mobx 也可以被认为是更繁琐的 Vue&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;v-model, 这只是通过语法糖定义了一个自定义指令，本质跟 React 一样. 修饰符&lt;code&gt;.async&lt;/code&gt; 也是一样&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;React是单向数据流，只能通过事件触发，然后再setState，React没有自定义指令&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;/&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;传统 HTML标签渲染 / jsx render渲染&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;jsx&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;/&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;Vuex&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;Redux&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;react 有一个中间件react-redux 可以让我们方便的使用 Redux&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;EventBus 非父子组件通信&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;&lt;a href=&quot;https://github.com/mroderick/PubSubJS&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PubSubJS&lt;/a&gt; 或 &lt;a href=&quot;http://millermedeiros.github.io/js-signals/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;js-signals&lt;/a&gt;&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;react-native 中还没用过，没遇到需要的场景&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;混入：mixins&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;class组件不可用，在使用 &lt;code&gt;createReactClass&lt;/code&gt; 创建 &lt;code&gt;React&lt;/code&gt; 组件的时候可用 mixins&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;我们可以要把 mixin 的东西写到单独的 js 文件里，通过 import 实现 mixin，这个本来就是锦上添花，不甚重要&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;slot&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;props.chldren&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;自定义组件获取使用时传入的子元素&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;自定义指令&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;自己通过事件触发实现类似效果&lt;/td&gt;&lt;td style=&quot;text-align:center&quot;&gt;自定义指令可以实现类似于 限制 input 输入格式 等效果&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;还有一些是两者非常类似的，只要会了一个，另一个也就会了：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;生命周期方法： 虽然名称不同，但使用一样&lt;/li&gt;&lt;li&gt;ref ： react 有多种使用 ref 的方法， 具体请看 &lt;a href=&quot;https://jintang.github.io/2018/05/11/react-native%E6%88%91%E4%BB%AC%E5%BA%94%E8%AF%A5%E7%9F%A5%E9%81%93%E7%9A%84/&quot;&gt;另外一篇文章&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="前端" scheme="https://jintang.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="react-native" scheme="https://jintang.github.io/tags/react-native/"/>
    
      <category term="vue" scheme="https://jintang.github.io/tags/vue/"/>
    
      <category term="react" scheme="https://jintang.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>区块链学习</title>
    <link href="https://jintang.github.io/2018/08/13/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%AD%A6%E4%B9%A0/"/>
    <id>https://jintang.github.io/2018/08/13/区块链学习/</id>
    <published>2018-08-13T14:57:20.000Z</published>
    <updated>2019-07-10T07:42:20.502Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Hash-函数"><a href="#Hash-函数" class="headerlink" title="Hash 函数"></a>Hash 函数</h3><p>区块链中区块相连是依靠：后一个区块持有前一个区块的 hash ，这个 hash 一般放在区块头中。 Hash 函数一般有两类：</p><ol><li>MD 系列： 如 MD5 ，已被证实不是特别安全</li><li>SH 系列： 是美国国家安全局 (NSA) 设计。经历了SHA-0，SHA-1，SHA-2，SHA-3系列发展，比特币采用SHA256算法，该算法属于SHA-2系列，在中本聪发明比特币时（2008）被公认为最安全最先进的算法之一</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Hash-函数&quot;&gt;&lt;a href=&quot;#Hash-函数&quot; class=&quot;headerlink&quot; title=&quot;Hash 函数&quot;&gt;&lt;/a&gt;Hash 函数&lt;/h3&gt;&lt;p&gt;区块链中区块相连是依靠：后一个区块持有前一个区块的 hash ，这个 hash 一般放在区块头中。 
    
    </summary>
    
      <category term="区块链" scheme="https://jintang.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="https://jintang.github.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>hello 智能合约</title>
    <link href="https://jintang.github.io/2018/08/03/hello-%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    <id>https://jintang.github.io/2018/08/03/hello-智能合约/</id>
    <published>2018-08-02T17:46:20.000Z</published>
    <updated>2019-07-10T07:50:43.644Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>欢迎查看 跟着大佬一起动手系列，点击<a href="https://learnblockchain.cn/2017/11/24/init-env/" target="_blank" rel="noopener">这儿</a>查看大佬的博文</p></blockquote><h2 id="什么是智能合约"><a href="#什么是智能合约" class="headerlink" title="什么是智能合约"></a>什么是智能合约</h2><p><strong>以太坊上的程序称之为智能合约，它是代码和数据(状态)的集合。</strong></p><p>如果做比喻的话智能合约更像是JAVA程序，JAVA程序通过JAVA虚拟机（JVM）将代码解释字节进行执行，以太坊的智能合约通过以太坊虚拟机（EVM）解释成字节码进行执行。</p><p>智能合约可以理解为在区块链上可以自动执行的（由消息驱动的）、以代码形式编写的合同（特殊的交易）。</p><p>比特币的交易是可以编程的，但是比特币脚本有很多的限制，能够编写的程序也有限，而以太坊具有 <a href="https://zh.wikipedia.org/wiki/%E5%9C%96%E9%9D%88%E5%AE%8C%E5%82%99%E6%80%A7" target="_blank" rel="noopener">图灵完备</a>，通俗来说可以完全模拟一台计算机所能做的所有事情。比特币可以执行一些简单脚本，但是他就不是图灵完备，比如循环指令比特币就无法执行。</p><h2 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h2><p>用户不可能直接编写以太坊虚拟机（EVM）字节码，所以以太坊提供了几种编写智能合约的高级语言。</p><p>Solidity：类似JavaScript，这是以太坊推荐的旗舰语言，也是最流行的智能合约语言。具体用法参加Solidity文档，地址：<a href="https://solidity.readthedocs.io/en/latest/" target="_blank" rel="noopener">https://solidity.readthedocs.io/en/latest/</a></p><blockquote><p>还有Viper，Serpent，LLL及Bamboo，建议大家还是使用Solidity。Serpent官方已经不再推荐，建议Serpent的用户转换到Viper，他们都是类Python语言。</p></blockquote><p>可以根据不同的习惯选择不同的高级语言，目前最流行的是Solidity。</p><p>我们下面使用 <a href="https://ethereum.github.io/browser-solidity/" target="_blank" rel="noopener">Browser-Solidity</a> IDE （也就是 Remix ）进行合约的编写和编译</p><a id="more"></a><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="以太坊客户端：-geth-安装"><a href="#以太坊客户端：-geth-安装" class="headerlink" title="以太坊客户端： geth 安装"></a>以太坊客户端： geth 安装</h3><p>在这儿我们使用 Geth ，全称是 go-ethereum，是以太坊的 go 语言命令行客户端，也是最流行的客户端 —— <a href="https://github.com/ethereum/go-ethereum/wiki/Building-Ethereum" target="_blank" rel="noopener">geth官方安装指引</a> 。</p><p>Geth提供了一个交互式命令控制台，通过命令控制台中包含了以太坊的各种功能（API）。拥有账户管理、挖矿、转账、智能合约的部署和执行等等功能。其中，EVM就是由以太坊客户端提供的。</p><blockquote><p>相对于Geth，Mist则是图形化操作界面的以太坊客户端。</p></blockquote><h3 id="使用geth启动环境"><a href="#使用geth启动环境" class="headerlink" title="使用geth启动环境"></a>使用geth启动环境</h3><blockquote><p>智能合约的开发需要使用以太坊的资源，所以是需要付费的，这个费用表现为 以太币。下面我们用 geth 启动开发者网络（模式）,会自动分配一个有大量余额的开发者账户给我们使用。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">geth --datadir testNet --dev console 2&gt;&gt; test.log</span><br></pre></td></tr></table></figure><p>参数解析，更多请查看<a href="https://github.com/ethereum/go-ethereum/wiki/Command-Line-Options" target="_blank" rel="noopener">这儿</a>:</p><ul><li><code>–dev</code> 启用开发者网络（模式），开发者网络会使用POA共识，默认预分配一个开发者账户并且会自动开启挖矿。</li><li><code>–datadir</code> 后面的参数是区块数据及秘钥存放目录。<br>第一次输入命令后，它会放在当前目录下新建一个testNet目录来存放数据。</li><li><code>console</code> 进入控制台</li><li><code>2&gt;&gt; test.log</code> 表示把控制台日志输出到test.log文件</li></ul><p>为了更好的理解，建议新开一个命令行终端，实时显示日志：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f test.log</span><br></pre></td></tr></table></figure><h3 id="准备账户"><a href="#准备账户" class="headerlink" title="准备账户"></a>准备账户</h3><p>智能合约的部署是指把合约字节码发布到区块链上，并使用一个特定的地址来标示这个合约，这个地址称为合约账户。</p><blockquote><p>以太坊中有两类账户：</p><ul><li>外部账户：该类账户被私钥控制（由人控制），没有关联任何代码。</li><li>合约账户: 该类账户被它们的合约代码控制且有代码与之关联。</li></ul><p><strong>外部账户与合约账户的区别和关系：</strong></p><p>一个外部账户可以通过创建和用自己的私钥来对交易进行签名，来发送消息给另一个外部账户或合约账户。在两个外部账户之间传送消息是价值转移的过程。</p><p>但从外部账户到合约账户的消息会激活合约账户的代码，允许它执行各种动作（比如转移代币，写入内部存储，挖出一个新代币，执行一些运算，创建一个新的合约等等）。</p><p>只有当外部账户发出指令时，合同账户才会执行相应的操作。</p></blockquote><p>智能合约的部署是指把合约字节码发布到区块链上，并使用一个特定的地址来标示这个合约，这个地址称为合约账户。</p><p>部署智能合约需要一个外部账户，我们先来看看分配的开发者账户，这个开发者账户里有充足的以太币。</p><p><em>查看账户:</em><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.accounts</span><br><span class="line"><span class="comment"># ["0x231b0a1ce4258e708cec69831f89d752822e25aa"] 返回了分配的开发者账户</span></span><br></pre></td></tr></table></figure><p></p><p><em>查看账户余额：</em><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.getBalance(eth.accounts[0])</span><br><span class="line"><span class="comment"># 1.15792089237316195423570985008687907853269984665640564039457584007913129639927e+77 数字非常大</span></span><br></pre></td></tr></table></figure><p></p><p>开发者账户因余额太多，如果用这个账户来部署合约时会无法看到余额变化，为了更好的体验完整的过程，这里选择创建一个新的账户。</p><p><em>创建账户:</em><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.newAccount(<span class="string">"tang"</span>)</span><br><span class="line"><span class="comment"># 返回了新的账号 "0x44e805ccb02b8c14e41d1e166e46d7b615c911ca"， tang 是账号密码</span></span><br><span class="line">&gt; eth.accounts</span><br><span class="line"><span class="comment"># ["0x231b0a1ce4258e708cec69831f89d752822e25aa", "0x44e805ccb02b8c14e41d1e166e46d7b615c911ca"] 多了一个</span></span><br><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line"><span class="comment"># 0 查看的是第二个账号的余额</span></span><br></pre></td></tr></table></figure><p></p><p><em>给新账号转账:</em> 转 1 ether 以太币, ether 是 以太币 的单位，以太币的最小单位是 wei ，详情查看 <a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#web3towei" target="_blank" rel="noopener">这儿</a><br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; eth.sendTransaction(&#123;from: <span class="string">'0x231b0a1ce4258e708cec69831f89d752822e25aa'</span>, to: <span class="string">'0x44e805ccb02b8c14e41d1e166e46d7b615c911ca'</span>, value: web3.toWei(1, <span class="string">"ether"</span>)&#125;)</span><br><span class="line"><span class="comment"># "0xf7953104df919ca3d44f262ed291c1a19a82ad34469af6bd4e2a1b7357d93a4f"</span></span><br><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line"><span class="comment"># 1000000000000000000</span></span><br></pre></td></tr></table></figure><p></p><p><em>解锁账户:</em> 在部署合约前需要先解锁账户（就像银行转账要输入密码一样）<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; personal.unlockAccount(eth.accounts[1],<span class="string">"tang"</span>, 0);</span><br><span class="line"><span class="comment"># true  第二个参数是对应账号的密码</span></span><br></pre></td></tr></table></figure><p></p><h2 id="编写、编译、部署-合约代码"><a href="#编写、编译、部署-合约代码" class="headerlink" title="编写、编译、部署 合约代码"></a>编写、编译、部署 合约代码</h2><p><em>solidity代码如下:</em><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.18</span>;</span><br><span class="line">contract hello &#123;</span><br><span class="line">    string greeting;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">string _greeting</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        greeting = _greeting;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">say</span>(<span class="params"></span>) <span class="title">constant</span> <span class="title">public</span> <span class="title">returns</span> (<span class="params">string</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> greeting;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们定义了一个名为hello的合约，在合约初始化时保存了一个字符串（我们会传入hello world），每次调用say返回字符串。</p><p>把这段代码写(拷贝)到 <a href="https://ethereum.github.io/browser-solidity/" target="_blank" rel="noopener">Browser-Solidity</a>，Browser-Solidity 要选中 <code>Auto Compile</code> 。如果没有错误，说明编译成功。点击Details获取部署代码（警告可以不理）。</p><p>在弹出的对话框中找到WEB3DEPLOY部分，点拷贝，粘贴到随便的一个编辑器后，修改初始化字符串为hello world。最后结果为：<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> _greeting = <span class="string">"hello world"</span> ;</span><br><span class="line"><span class="comment">// Creates a contract object</span></span><br><span class="line"><span class="keyword">var</span> helloContract = web3.eth.contract([&#123;<span class="string">"constant"</span>:<span class="literal">true</span>,<span class="string">"inputs"</span>:[],<span class="string">"name"</span>:<span class="string">"say"</span>,<span class="string">"outputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">""</span>,<span class="string">"type"</span>:<span class="string">"string"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"view"</span>,<span class="string">"type"</span>:<span class="string">"function"</span>&#125;,&#123;<span class="string">"inputs"</span>:[&#123;<span class="string">"name"</span>:<span class="string">"_greeting"</span>,<span class="string">"type"</span>:<span class="string">"string"</span>&#125;],<span class="string">"payable"</span>:<span class="literal">false</span>,<span class="string">"stateMutability"</span>:<span class="string">"nonpayable"</span>,<span class="string">"type"</span>:<span class="string">"constructor"</span>&#125;]);</span><br><span class="line"><span class="comment">// deploy new contract</span></span><br><span class="line"><span class="keyword">var</span> hello = helloContract.new(</span><br><span class="line">   _greeting, <span class="comment">// constructorParam, 可存在多个</span></span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">from</span>: web3.eth.accounts[<span class="number">1</span>],  <span class="comment">// 部署账号</span></span><br><span class="line">     data: <span class="string">'0x608060405234801561001057600080fd5b5060405161027c38038061027c83398101604052805101805161003a906000906020840190610041565b50506100dc565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f1061008257805160ff19168380011785556100af565b828001600101855582156100af579182015b828111156100af578251825591602001919060010190610094565b506100bb9291506100bf565b5090565b6100d991905b808211156100bb57600081556001016100c5565b90565b610191806100eb6000396000f3006080604052600436106100405763ffffffff7c0100000000000000000000000000000000000000000000000000000000600035041663954ab4b28114610045575b600080fd5b34801561005157600080fd5b5061005a6100cf565b6040805160208082528351818301528351919283929083019185019080838360005b8381101561009457818101518382015260200161007c565b50505050905090810190601f1680156100c15780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b60008054604080516020601f600260001961010060018816150201909516949094049384018190048102820181019092528281526060939092909183018282801561015b5780601f106101305761010080835404028352916020019161015b565b820191906000526020600020905b81548152906001019060200180831161013e57829003601f168201915b50505050509050905600a165627a7a7230582095d42238dd45ab5b9cf241235d3dbba2dae94a09053bc96b0935ed98ac9a4ec10029'</span>,  <span class="comment">// 合约编译后的字节码</span></span><br><span class="line">     gas: <span class="string">'4700000'</span> <span class="comment">// 以太坊用 gas 计算要智能合约需要的以太币</span></span><br><span class="line">   &#125;, <span class="function"><span class="keyword">function</span> (<span class="params">e, contract</span>)</span>&#123; <span class="comment">// 部署后的回调函数</span></span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> The callback will fire twice!</span></span><br><span class="line">    <span class="comment">// Once the contract has the transactionHash property set and once its deployed on an address.</span></span><br><span class="line">    <span class="built_in">console</span>.log(e, contract);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> contract.address !== <span class="string">'undefined'</span>) &#123;</span><br><span class="line">         <span class="built_in">console</span>.log(<span class="string">'Contract mined! address: '</span> + contract.address + <span class="string">' transactionHash: '</span> + contract.transactionHash);</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p></p><p><code>eth.contract</code> ：<a href="https://solidity.readthedocs.io/en/develop/abi-spec.html" target="_blank" rel="noopener">api说明</a></p><blockquote><p>需要修改的地方：</p><ul><li>第1行：修改字符串为 hello world</li><li>第6行：修改部署账户为新账户索引，即使用新账户来部署合约。</li></ul></blockquote><p>然后一行一行拷贝到 geth 中执行。出现以下类似 log 说明 <strong>部署成功</strong>。<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Contract mined! address: 0x8500c68000dbbebea6d5673d28927b28b9470854 transactionHash: 0x16c8aa6129693edaf22b43fd043748857d05511251f65b5e9f9faf8355b95656</span><br><span class="line">&gt; eth.getBalance(eth.accounts[1])</span><br><span class="line"><span class="comment"># 查看账号余额，发现变少了</span></span><br></pre></td></tr></table></figure><p></p><p>同时也可以在日志中看到挖矿记录等<br><img src="https://tang-blog-1257996120.cos-website.ap-chengdu.myqcloud.com/mine-log.png" alt="mine-log"></p><h2 id="运行合约"><a href="#运行合约" class="headerlink" title="运行合约"></a>运行合约</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hello.say()</span><br><span class="line"><span class="comment"># hello world</span></span><br></pre></td></tr></table></figure><p>不知道为什么公司的电脑运行成功了，而家里的电脑却报错了 <code>TypeError: &#39;say&#39; is not a function</code>，明明合约创建成功了。</p><p>跟上面截图的最底部的 error: <code>waiting for transactions</code> 没关系，公司的电脑上也有这行日志。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;&lt;p&gt;欢迎查看 跟着大佬一起动手系列，点击&lt;a href=&quot;https://learnblockchain.cn/2017/11/24/init-env/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这儿&lt;/a&gt;查看大佬的博文&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id=&quot;什么是智能合约&quot;&gt;&lt;a href=&quot;#什么是智能合约&quot; class=&quot;headerlink&quot; title=&quot;什么是智能合约&quot;&gt;&lt;/a&gt;什么是智能合约&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;以太坊上的程序称之为智能合约，它是代码和数据(状态)的集合。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;如果做比喻的话智能合约更像是JAVA程序，JAVA程序通过JAVA虚拟机（JVM）将代码解释字节进行执行，以太坊的智能合约通过以太坊虚拟机（EVM）解释成字节码进行执行。&lt;/p&gt;&lt;p&gt;智能合约可以理解为在区块链上可以自动执行的（由消息驱动的）、以代码形式编写的合同（特殊的交易）。&lt;/p&gt;&lt;p&gt;比特币的交易是可以编程的，但是比特币脚本有很多的限制，能够编写的程序也有限，而以太坊具有 &lt;a href=&quot;https://zh.wikipedia.org/wiki/%E5%9C%96%E9%9D%88%E5%AE%8C%E5%82%99%E6%80%A7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;图灵完备&lt;/a&gt;，通俗来说可以完全模拟一台计算机所能做的所有事情。比特币可以执行一些简单脚本，但是他就不是图灵完备，比如循环指令比特币就无法执行。&lt;/p&gt;&lt;h2 id=&quot;编程语言&quot;&gt;&lt;a href=&quot;#编程语言&quot; class=&quot;headerlink&quot; title=&quot;编程语言&quot;&gt;&lt;/a&gt;编程语言&lt;/h2&gt;&lt;p&gt;用户不可能直接编写以太坊虚拟机（EVM）字节码，所以以太坊提供了几种编写智能合约的高级语言。&lt;/p&gt;&lt;p&gt;Solidity：类似JavaScript，这是以太坊推荐的旗舰语言，也是最流行的智能合约语言。具体用法参加Solidity文档，地址：&lt;a href=&quot;https://solidity.readthedocs.io/en/latest/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://solidity.readthedocs.io/en/latest/&lt;/a&gt;&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;还有Viper，Serpent，LLL及Bamboo，建议大家还是使用Solidity。Serpent官方已经不再推荐，建议Serpent的用户转换到Viper，他们都是类Python语言。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;可以根据不同的习惯选择不同的高级语言，目前最流行的是Solidity。&lt;/p&gt;&lt;p&gt;我们下面使用 &lt;a href=&quot;https://ethereum.github.io/browser-solidity/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Browser-Solidity&lt;/a&gt; IDE （也就是 Remix ）进行合约的编写和编译&lt;/p&gt;
    
    </summary>
    
      <category term="区块链" scheme="https://jintang.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="智能合约" scheme="https://jintang.github.io/tags/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>node常用</title>
    <link href="https://jintang.github.io/2018/07/16/node%E5%B8%B8%E7%94%A8/"/>
    <id>https://jintang.github.io/2018/07/16/node常用/</id>
    <published>2018-07-16T01:53:51.000Z</published>
    <updated>2018-08-12T07:26:35.252Z</updated>
    
    <content type="html"><![CDATA[<h2 id="node常用命令"><a href="#node常用命令" class="headerlink" title="node常用命令"></a>node常用命令</h2><h3 id="进入、退出命令行"><a href="#进入、退出命令行" class="headerlink" title="进入、退出命令行"></a>进入、退出命令行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入命令行</span></span><br><span class="line">node</span><br><span class="line"><span class="comment"># 正常退出退出命令行</span></span><br><span class="line">.<span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 强制退出</span></span><br><span class="line">ctrl + c <span class="comment"># 两次</span></span><br></pre></td></tr></table></figure><h3 id="调试模式"><a href="#调试模式" class="headerlink" title="调试模式"></a>调试模式</h3><p>谷歌浏览器内置了 <code>node</code> 的调试器，可以很方便的打断点，看 log , 我们需要以调试模式运行 <code>node</code> 程序<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node --inspect index</span><br><span class="line"><span class="comment"># 也是以node --inspect的方式启动，只不过加了supervisor的保存即时生效</span></span><br><span class="line">supervisor --inspect index</span><br></pre></td></tr></table></figure><p></p><h3 id="软连接全局-node-包"><a href="#软连接全局-node-包" class="headerlink" title="软连接全局 node 包"></a>软连接全局 node 包</h3><p>我们可以通过 <code>npm install -g 包名</code> 的方式全局安装第远程包，但对于没有在 <code>node</code> 仓库的包无能为力。这儿有另一种方法全局添加自己写的包<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> 文件夹</span><br><span class="line">npm link</span><br></pre></td></tr></table></figure><p></p><p>在全局的包仓库下引用了此仓库，原理类似于快捷方式。然后就可以全局使用自己的包命令了，不想用了的话删除软连接<br></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm unlink</span><br></pre></td></tr></table></figure><p></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;node常用命令&quot;&gt;&lt;a href=&quot;#node常用命令&quot; class=&quot;headerlink&quot; title=&quot;node常用命令&quot;&gt;&lt;/a&gt;node常用命令&lt;/h2&gt;&lt;h3 id=&quot;进入、退出命令行&quot;&gt;&lt;a href=&quot;#进入、退出命令行&quot; class=&quot;headerlink&quot; title=&quot;进入、退出命令行&quot;&gt;&lt;/a&gt;进入、退出命令行&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 进入命令行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;node&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 正常退出退出命令行&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;.&lt;span class=&quot;built_in&quot;&gt;exit&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 强制退出&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ctrl + c &lt;span class=&quot;comment&quot;&gt;# 两次&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;调试模式&quot;&gt;&lt;a href=&quot;#调试模式&quot; class=&quot;headerlink&quot; title=&quot;调试模式&quot;&gt;&lt;/a&gt;调试模式&lt;/h3&gt;&lt;p&gt;谷歌浏览器内置了 &lt;code&gt;node&lt;/code&gt; 的调试器，可以很方便的打断点，看 log , 我们需要以调试模式运行 &lt;code&gt;node&lt;/code&gt; 程序&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;node --inspect index&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 也是以node --inspect的方式启动，只不过加了supervisor的保存即时生效&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;supervisor --inspect index&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h3 id=&quot;软连接全局-node-包&quot;&gt;&lt;a href=&quot;#软连接全局-node-包&quot; class=&quot;headerlink&quot; title=&quot;软连接全局 node 包&quot;&gt;&lt;/a&gt;软连接全局 node 包&lt;/h3&gt;&lt;p&gt;我们可以通过 &lt;code&gt;npm install -g 包名&lt;/code&gt; 的方式全局安装第远程包，但对于没有在 &lt;code&gt;node&lt;/code&gt; 仓库的包无能为力。这儿有另一种方法全局添加自己写的包&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;cd&lt;/span&gt; 文件夹&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;npm link&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;在全局的包仓库下引用了此仓库，原理类似于快捷方式。然后就可以全局使用自己的包命令了，不想用了的话删除软连接&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;npm unlink&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="node" scheme="https://jintang.github.io/categories/node/"/>
    
    
      <category term="node" scheme="https://jintang.github.io/tags/node/"/>
    
  </entry>
  
</feed>
